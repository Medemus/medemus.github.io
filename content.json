{"meta":{"title":"MBLOG","subtitle":"","description":"","author":"MEUSA","url":"https://github.com/Medemus/medemus.github.io","root":"/"},"pages":[{"title":"about","date":"2020-02-23T11:20:33.000Z","updated":"2020-10-28T13:48:09.673Z","comments":true,"path":"about/index.html","permalink":"https://github.com/Medemus/medemus.github.io/about/index.html","excerpt":"","text":"欢迎~"},{"title":"","date":"2021-03-09T15:13:46.674Z","updated":"2021-03-09T15:13:46.674Z","comments":true,"path":"404.html","permalink":"https://github.com/Medemus/medemus.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2021-03-09T15:11:16.590Z","updated":"2021-03-09T15:11:16.590Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Medemus/medemus.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-03-09T15:12:07.989Z","updated":"2021-03-09T15:12:07.989Z","comments":true,"path":"mylist/index.html","permalink":"https://github.com/Medemus/medemus.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-09T15:11:44.125Z","updated":"2021-03-09T15:11:44.125Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/Medemus/medemus.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"自制NavMesh2D（四）","slug":"自制NavMesh2D（四）","date":"2020-11-12T12:56:23.000Z","updated":"2021-03-09T15:21:27.184Z","comments":true,"path":"2020/11/12/自制NavMesh2D（四）/","link":"","permalink":"https://github.com/Medemus/medemus.github.io/2020/11/12/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"图源：https://www.pixiv.net/artworks/83559708 自制NavMesh2D（四）在有了一个简单的NavMesh后，开始回到第一步，构建多边形。 根据sprite顶点生成由于是基于2D所制作的，所以我在这没有选择“光栅化”去获取边界，而是直接拿到sprite的顶点信息，甚至直接拿到三角形的信息，通过给其标记为寻路网格或者障碍物来控制多边形的合成（偷个懒）。 例如对于一个默认的长方形sprite其拥有顶点与三角形的信息，而这些其实可以直接利用到生成中。 另外由于如果只是拿到顶点信息，由于其并不是按照顺时针或逆时针排序的，所以仅凭顶点是无法获取多边形数据的（对于较复杂的凹多边形而言），所以需要获得其三角形的列表，其有着顶点之间的关系信息。 其实如果只是根据这些信息生成多边形，再剖分成三角形，貌似有点多此一举（拿到三角形的信息，生成多边形，再生成三角形），所以对于不需要障碍物的NavMesh就可以直接根据这些三角形转换成需要的寻路三角形进行使用了。当然更普遍的情况是存在障碍物甚至动态障碍物，其中动态障碍物需要能够进行局部的网格重新生成（如果重新生成整张网格其实有很大一部分没有变化，同时会造成不必要的性能开销）。同时为了尽量减少工作量（偷懒），这里我对障碍物的处理是：获取被障碍物覆盖的三角形-&gt;将这些三角形合并成多边形-&gt;进行内外多边形的合并-&gt;剖分成新的三角形列表。 那么如何获取被覆盖的三角形有哪些呢，由于我没在网上搜到类似资料，所以采用的是最粗暴的遍历法——多变形的每条边与没有检测到的三角形的边检测是否相交，如果相交则将该边对应的两个三角形加入合并列表。 然后以合并列表中的三角形的一条无邻居的边（以保证该边不是多边形内部边）的起点为起点，绕边缘描绘出多边形。 例如在下面这个合并三角形列表中，以b边的起点B作为遍历起点，然后找到其终点C，再以C为起点找到D······，就能够描绘出这些三角形构成的多变形了。（此处都已规定除障碍物/内部多边形外都是顺时针排布） 对于这个构造出来的多边形，再使用内外多边形合并的操作，然后进行剖分，就能够得到新的三角形列表了，最后再将这些三角形添加回原三角形列表，更新三角形的相邻关系与ID即可。 对于越界的障碍物障碍物可不会老老实实待在多边形内部，更常见的情况是障碍物会与多边形边界相交。 如下面绿色的障碍物有一部分再白色地面的外部。 那么此时要做的就是将这块覆盖的区域“剔除”。 先从这种最简单的情况考虑，可以看出边界与障碍物的边交于两点，那么剔除后的多边形应为A-&gt;B-&gt;C-&gt;D-&gt;N-&gt;M-&gt;E-&gt;O-&gt;A。此时规定障碍物与多边形的方向相反的好处再次体现出来了，能够根据交点很方便得获得增添的新顶点。 添加顺序为离边界起点（这里是D）近的边（这里是GM）的起点、交点（这里是N）、终点（M）、内部顶点、较远的边（EF）重复GM的顺序。 如果多边形的顶点在障碍物的内部的话，则需将该顶点删去。 简单的写个脚本来测试 可以看到已经能够正确剔除了。换个情况 对于分割了多边形的障碍物还有种情况，那就是一个障碍物分割开了多边形，那么上面这种方法就不行了。在搜索了资料后，最相似的情况便是图形学中的三角形裁剪，可是情况不一样的是一个是求两多边形的交集，一个是求补集，但其思路是差不多的，问题就在于如何找到点之间的关系。这里参考了任意多边形切割/裁剪使用链表进行分割的思路。 如该图所示的障碍物（EFGH）将多边形（ABCD）分割成了两块，分别是A-&gt;e1-&gt;e2-&gt;D 和 B-&gt;C-&gt;e3-&gt;e4。 用链表图表示其中一部分变化就是由 变成了 看得出插入位置在交点所在线的端点中间，且端点为起点还是终点与插入的方向是有关的。如果端点是起点，那么是端点连接交点，如果是终点，则是交点连接端点。如果相邻交点的连线在多边形内，则连接上，而由于多边形规定为顺时针，障碍物为逆时针，所以可以根据相交边的方向来判断。 综上两点，举例：1、F-&gt;G与A-&gt;B交于e1：如果从障碍物的边的终点看向起点，相交边的起点在左侧，将交点e1插入F-&gt;G间，可以得知左侧端点为起点，那么将A连接上e1，同时根据相交线段的方向知道是进入多边形，所以将交点放入栈暂存。2、F-&gt;G与C-&gt;D交于e2：如果从障碍物的边的终点看向起点，相交边的终点在左侧，将交点e2插入e1-&gt;G间，可以得知左侧端点为终点，那么将e2连接上D，同时根据相交线段的方向知道是离开多边形，如果此时栈内有交点，取出并将该交点（e1）连接上e2。 由此就构建出了一个由循环链表构成的多边形A-&gt;e1-&gt;e2-&gt;D了，B-&gt;C-&gt;e3-&gt;e4同理。 通过遍历多边形的顶点，解构出两个循环链表便是所需的多边形了。 可以看到上图将障碍物的顶点链表也包含进来了，原因是有种情况即障碍物的顶点在多边形内部时，需要将该顶点包含进来，而使用链表即可很好解决这些包含进来的顶点之间的关系。 这块代码写得有点乱完整版就暂时不贴了（ 核心代码 123456789101112131415161718192021222324public List&lt;Polygon&gt; Clips(Polygon ob)&#123;//············· foreach (var node in intersection) &#123; //查找交点的左侧的点是起点还是终点 if (curObLine.ClassifyPoint(crossLines[node].start) == PointSide.LEFT_SIDE)//起点在左侧 &#123; outerPoints[lineIndex[crossLines[node]]].Next = node;//起点连接交点 crossPoint.Push(node);//交点放入栈中 &#125; else//否则终点在左侧 &#123; var index = lineIndex[crossLines[node]] == points.Count - 1 ? 0 : lineIndex[crossLines[node]] + 1;//该终点在多边形中的index node.Next = outerPoints[index]; if (crossPoint.Count &gt; 0)//如果栈中有点，即如果该线之前有交点 &#123; var lastcross = crossPoint.Pop(); lastcross.Next = node; &#125; &#125; &#125;//·············&#125; 再简单的写个测试脚本验证下： 白色矩形为多边形，红色为障碍物。 进行切割后 如果障碍物遮住了多边形顶点的情况：","categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]},{"title":"自制NavMesh2D（三）","slug":"自制NavMesh2D（三）","date":"2020-11-08T12:56:23.000Z","updated":"2021-03-09T15:21:36.135Z","comments":true,"path":"2020/11/08/自制NavMesh2D（三）/","link":"","permalink":"https://github.com/Medemus/medemus.github.io/2020/11/08/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"图源：https://www.pixiv.net/artworks/85447522 自制NavMesh2D（三）对三角形进行A*寻路在获得具体路径之前，需要知道走过了哪些三角形，只有知道需要经过哪些三角形才能进行接下来的路径规划，而一般这步操作是由A*算法来进行的。 在常见情况下，A*往往是对二维网格进行操作。 那么如果要在不规则的三角形集合中进行A寻路，看上去似乎有很大不同，但其实本质是一样的，在（二）中，为了支持三角形进行A寻路，为其增添了一些参数，并规定了在三角形中的G与H的计算规则，这样就能按照常规的方法来进行A*寻路的操作了。 首先是要获取终点与终点所在的三角形： 123456789101112131415NavTriangle startNavTriangle = null, endNavTriangle = null;foreach (var triangle in navMeshData)//获取起始三角形与终点三角形&#123; if (startNavTriangle == null) if (MUtil.IsPointIn(start, triangle)) startNavTriangle = triangle; if (endNavTriangle == null) if (MUtil.IsPointIn(end, triangle)) endNavTriangle = triangle; if(startNavTriangle != null &amp;&amp; endNavTriangle != null) break;&#125; 进行A*相关操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//A*寻路bool isFound = false;int traversalTimes = 1;List&lt;NavTriangle&gt; openList = new List&lt;NavTriangle&gt;(); //开放列表List&lt;NavTriangle&gt; closeList = new List&lt;NavTriangle&gt;();startNavTriangle.traversalTimes = traversalTimes;openList.Add(startNavTriangle);Debug.LogWarning(&quot;start:&quot; + startNavTriangle.ID);int tmp = 10000;while (openList.Count &gt; 0 &amp;&amp; tmp &gt; 0)&#123; --tmp; NavTriangle curNode; curNode = openList[openList.Count - 1]; openList.Remove(curNode); closeList.Add(curNode); if (curNode.ID == endNavTriangle.ID) &#123; isFound = true; break; &#125; for (int i = 0; i &lt; 3; ++i) &#123; int index = curNode.neighborID[i]; NavTriangle neighboTriangle; if (index &lt; 0) &#123; continue; &#125; else &#123; neighboTriangle = navMeshData[index]; &#125; if (neighboTriangle.groupID == startNavTriangle.groupID) &#123; if (neighboTriangle.traversalTimes != traversalTimes)//如果没有遍历过 &#123; neighboTriangle.traversalTimes = traversalTimes; neighboTriangle.parentID = curNode.ID;//将邻居的父节点设置为当前节点 neighboTriangle.isOpen = true; neighboTriangle.CalcHeuristic(end);//计算H neighboTriangle.G = curNode.G + curNode.GetCost(neighboTriangle.ID);//计算G openList.Add(neighboTriangle);//加入openList openList.Sort(CompareTriWithFValue);//根据F排序 neighboTriangle.inWallIndex = curNode.ID;//进入边为cur &#125; else//如果已在open中 &#123; if (neighboTriangle.isOpen) &#123; if (neighboTriangle.G + neighboTriangle.GetCost(curNode.ID) &lt; curNode.G)//如果当前到达邻居的G小于原来的G，则更新该邻居 &#123; Debug.Log(&quot;change:&quot;+neighboTriangle.ID); curNode.G = neighboTriangle.G + neighboTriangle.GetCost(curNode.ID); curNode.parentID = neighboTriangle.ID; curNode.inWallIndex = neighboTriangle.ID; &#125; &#125; else &#123; neighboTriangle = null; continue; &#125; &#125; &#125; &#125;&#125;//遍历 完成上述操作后即可在closeList中通过每个三角形的父节点获取完整的三角形列表。 测试，绿色点为起点，黄色为终点： 计算路径在有了三角形后，就可以将其转换为具体的路径了。 通过计算拐点获得路径上的路径点，再将这些路径点连接起来便是所需要的路径了。 所以这一步的关键操作就在于如何获取拐点。NavMesh 设计一个方法，用来获取下一个拐点： 所需要的相关信息： 123456789101112public Vector2 GetNextWayPoint(Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,ref int curIndex)&#123; var tri = pathList[curIndex];//当前路径点所在的三角形 var outLine = tri.GetLineByIndex(tri.outWallIndex);//获取当前三角形的离开边 int lastIndex1 = curIndex;//当前左侧那条边的所在三角形的index int lastIndex2 = curIndex;//当前右侧那条边的所在三角形的index Line l1 = new Line(way,outLine.start);//右侧那条边，路径点-&gt;离开边的起点 Line l2 = new Line(way,outLine.end);//左侧那条边，路径点-&gt;离开边的终点 Vector2 targetPoint1, targetPoint2;//下一个离开边的起点和终点（两条边下一个到达的位置） ///········&#125; 开始遍历： 1234567891011121314151617181920public Vector2 GetNextWayPoint(Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,ref int curIndex)&#123; ///········ for (int i = curIndex + 1; i &lt; pathList.Count; ++i)//从三角形列表的下一个开始遍历 &#123; tri = pathList[i]; outLine = tri.GetLineByIndex(tri.outWallIndex);//下一个三角形的离开边 if (i == pathList.Count - 1) &#123; targetPoint1 = targetPoint2 = end;//如果已经到了最后一个三角形，直接指向终点 &#125; else &#123; targetPoint1 = outLine.start; targetPoint2 = outLine.end; &#125; ///········ &#125;&#125; 遍历时具体的判定： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public Vector2 GetNextWayPoint(Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,ref int curIndex)&#123; ///········ for (int i = curIndex + 1; i &lt; pathList.Count; ++i)//从三角形列表的下一个开始遍历 &#123; ///········ if (!MMath.IsEqual(targetPoint1, l1.end))//如果移动到的下一个边的点与当前点一样的话就不需要移动 &#123; if (l2.ClassifyPoint(targetPoint1) == PointSide.LEFT_SIDE)//如果右侧边的目标点在左侧边的左侧（代表漏斗角的度数变成负数） &#123; //左侧边的当前点就是拐点 curIndex = lastIndex1; Vector2 nextPoint = l2.end; return nextPoint; &#125;else if (l1.ClassifyPoint(targetPoint1) != PointSide.RIGHT_SIDE)//如果右侧边的目标点没有在其右侧（角度没有变大） &#123; //正常移动 lastIndex1 = i; l1.end = targetPoint1; &#125; &#125; if (!MMath.IsEqual(targetPoint2, l2.end))//如果移动到的下一个边的点与当前点一样的话就不需要移动 &#123; /*Debug.DrawLine(l2.start,targetPoint2);*/ if (l1.ClassifyPoint(targetPoint2) == PointSide.RIGHT_SIDE)//如果左侧边的目标点在右侧边的右侧（代表漏斗角的度数变成负数） &#123; //右侧边的当前点就是拐点 Vector2 nextPoint = l1.end; curIndex = lastIndex2; return nextPoint; &#125;else if (l2.ClassifyPoint(targetPoint2) != PointSide.LEFT_SIDE)//如果左侧边的目标点没有在其左侧（角度没有变大） &#123; //正常移动 lastIndex2 = i; l2.end = targetPoint2; &#125; &#125; &#125; Vector2 wayPoint = end; curIndex = pathList.Count - 1; return wayPoint;&#125; 通过这样，就能够获取到下一个拐点，然后再将该拐点的所在三角形作为当前三角形，获取下一个拐点（路径点），直到路径点为终点，结束寻找。 123456789101112var point = start;wayPoints.Add(point);int curIndex = 0;while (!(point == end))//如果获取到的拐点（路径点）不是终点&#123; point = GetNextWayPoint(point, pathList, end, ref curIndex);//获取下一个拐点 if (point == null) &#123; return false; &#125; wayPoints.Add(point);//将获取到的点添加进路径点列表&#125; 测试：","categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]},{"title":"自制NavMesh2D（二）","slug":"自制NavMesh2D（二）","date":"2020-11-04T12:56:23.000Z","updated":"2021-03-09T15:21:41.362Z","comments":true,"path":"2020/11/04/自制NavMesh2D（二）/","link":"","permalink":"https://github.com/Medemus/medemus.github.io/2020/11/04/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"图源：https://www.pixiv.net/artworks/85217491 自制NavMesh2D（二）根据上面的学习，能够大致了解一个NavMesh2D的制作流程了，所以接下来就是上手实践。在此参考了Unity3D架构设计NavMesh寻路的设计。 根据顶点生成多边形由于所制作的为纯2D，是可以由sprite的顶点信息获取边缘信息的，所以在此我想先跳过光栅化的阶段，先行从多边形生成开始。 在此需要制定多边形类的信息，在此设定的多边形类的参数为List&lt;Vector&gt;类型的顶点列表。 12345678910111213141516171819202122232425public class Polygon &#123; public List&lt;Vector2&gt; points; public Polygon() &#123; points = new List&lt;Vector2&gt;(); &#125; public Polygon(List&lt;Vector2&gt; vertices) &#123; points = new List&lt;Vector2&gt;(); foreach (var vertex in vertices) &#123; points.Add(vertex); &#125; &#125; public Polygon(Vector2[] vertices) &#123; points = new List&lt;Vector2&gt;(); foreach (var vertex in vertices) &#123; points.Add(vertex); &#125; &#125; &#125; 有了点就该有线了，那么线应该就是由一个起点与一个终点所组成。 1234567891011public class Line &#123; public Vector2 start; public Vector2 end; public Line(Vector2 start, Vector2 end) &#123; this.start = start; this.end = end; &#125; &#125; 然后只要规定一个连线顺序（在这我规定的是外多边形为顺时针，内多边形为逆时针），就可以描述一个多边形了。 用Gizmo来绘制测试一下 对单个多边形进行三角形剖分多边形有了后，就该着手进行剖分了，先不考虑存在空洞、相交的情况。 为了进行剖分，首先需要构建三角形类，三角形的组成和多边形类似，但为了进行一些操作所以需要更多的参数。 123456789101112131415161718192021222324public class Triangle &#123; public Vector2[] points;//顶点列表 public int ID;//每个三角形的ID public int[] neighborID;//三角形邻居节点ID public Vector2 center;//中心点 public Triangle() &#123; points = new Vector2[3]; neighborID = new int[] &#123; -1, -1, -1 &#125;; center = Vector2.zero; &#125; public Triangle(Vector2 pos1,Vector2 pos2,Vector2 pos3,int id) &#123; points = new[] &#123;pos1, pos2, pos3&#125;; ID = id; neighborID = new[] &#123;-1, -1, -1&#125;; center.x = (points[0].x + points[1].x + points[2].x) / 3; center.y = (points[0].y + points[1].y + points[2].y) / 3; &#125; &#125; 在剖分前，还需要几个工具类进行辅助操作。 在工具类Util中，添加以下方法： 12345678910111213141516171819202122/// &lt;summary&gt;/// 获取多边形在三角形内部的点/// &lt;/summary&gt;public static bool TryGetInnerPoints(Triangle triangle,Polygon polygon,out List&lt;int&gt; res)&#123; res = new List&lt;int&gt;(); List&lt;Vector2&gt; points = polygon.points; HashSet&lt;Vector2&gt; trianglePoints = new HashSet&lt;Vector2&gt;(triangle.points); for (int i = 0; i &lt; points.Count; i++) &#123; if (!trianglePoints.Contains(points[i])) &#123; if (MUtil.IsPointIn(points[i], triangle))//是否有点在三角形内部 &#123; res.Add(i); &#125; &#125; &#125; if (res.Count &gt; 0) return true; return false;&#125; 123456789101112131415161718192021222324252627282930/// &lt;summary&gt;/// 指定点是否在三角形中/// &lt;/summary&gt;public static bool IsPointIn(Vector2 point,Triangle triangle)&#123; Vector3 AB = triangle.points[1] - triangle.points[0]; Vector3 AC = triangle.points[2] - triangle.points[0]; Vector3 AP = point - triangle.points[0]; float ABAB = Vector3.Dot(AB, AB); float ABAC = Vector3.Dot(AB, AC); float ABAP = Vector3.Dot(AB, AP); float ACAC = Vector3.Dot(AC, AC); float ACAP = Vector3.Dot(AC, AP); float inverDeno = 1 / (ABAB * ACAC - ABAC * ABAC); float u = (ACAC * ABAP - ABAC * ACAP) * inverDeno; if (u &lt; 0 || u &gt; 1) &#123; return false; &#125; float v = (ABAB * ACAP - ABAC * ABAP) * inverDeno; if (v &lt; 0 || v &gt; 1) &#123; return false; &#125; return u + v &lt;= 1;&#125; 在三角形类中，添加方法： 123456789101112131415161718192021222324252627/// &lt;summary&gt;/// 获取三角形的指定边/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public Line GetLineByIndex(int index)&#123; Line line; switch (index) &#123; case 0: line = new Line(this.points[0], this.points[1]); break; case 1: line = new Line(this.points[1], this.points[2]); break; case 2: line = new Line(this.points[2], this.points[0]); break; default: line = new Line(this.points[0], this.points[1]); break; &#125; return line;&#125; 为了获取三角形之间的关系，所以需要有 1234567891011121314151617181920/// &lt;summary&gt;/// 获取与指定三角形相邻的边/// &lt;/summary&gt;public bool TryGetNeighbor(Triangle triangle,out int res)&#123; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (GetLineByIndex(i).Equals(triangle.GetLineByIndex(j))) &#123; res = i; return true; &#125; &#125; &#125; res = -1; return false;&#125; 由此就可以进行接下来的剖分操作了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// &lt;summary&gt;/// 进行切耳三角剖分/// &lt;/summary&gt;public List&lt;Triangle&gt; EarCliping()&#123; Clockwise();//进行一次顺时针排序，以保证顺序 List&lt;Triangle&gt; res = new List&lt;Triangle&gt;(); List&lt;Vector2&gt; pointsTmp = new List&lt;Vector2&gt;(points); int tmp = 10000;//避免出现错误导致死循环死机而设置的最大循环上限数 int id = 0; while (pointsTmp.Count &gt; 3 &amp;&amp; tmp &gt; 0)//当未剖分的顶点在三个以上时 &#123; tmp--; for (int i = 0; i &lt; pointsTmp.Count; ++i) &#123; Triangle triangle = new Triangle(pointsTmp[i - 1 &lt; 0 ? pointsTmp.Count - 1:i-1], pointsTmp[i],pointsTmp[i + 1 &gt;= pointsTmp.Count ? 0 : i + 1],0);//以i为中间顶点设置三角形 if(triangle.GetLineByIndex(0).ClassifyPoint(triangle.center) != PointSide.LEFT_SIDE)//如果构成的三角形的中心不在线的内侧，就代表这是个凹点 continue; if (!MUtil.TryGetInnerPoints(triangle,this, out List&lt;int&gt; inners))//如果这个三角形内没有其他点，那就是耳朵 &#123; triangle.ID = id; ++id; res.Add(triangle);//添加这个耳朵三角形 pointsTmp.RemoveAt(i);//从原多边形中裁去 break; &#125; &#125; &#125; Triangle last = new Triangle(pointsTmp[0],pointsTmp[1],pointsTmp[2],id);//将最后三个顶点组成三角形 res.Add(last); /*for (int i = 0; i &lt; res.Count; i++) &#123; var tri = res[i]; for (int j = 0; j &lt; res.Count; j++) &#123; var triNext = res[j]; if(tri.ID == triNext.ID) continue; if (tri.TryGetNeighbor(triNext, out int index)) &#123; tri.SetNeighbor(index,triNext.ID); &#125; &#125; &#125;*/ MUtil.FindNeiborgh(res);//将上面查找并设置邻居的代码封装到工具类中了 return res;&#125; 进行测试，现在已经可以获得剖分后的三角形了 对内部有空洞的多边形进行剖分下一步就是如果内部存在空洞的情况了，在这先只考虑简单情况，即不出现套娃型空洞。如图所示： 那么需要做的就是先将内部空洞多边形与外部合并成简单多边形，此处则需要寻找到互相可见点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 寻找互相可见点/// &lt;/summary&gt;public static int[] FindVisiblePoint(Polygon outer, Polygon inner)&#123; int[] ans = new int[2];//0为内部空洞的互相可见点的index，1为外部多边形的 var xMaxPoint = inner.GetXMaxPointIndex();//遍历寻找内部多边形x值最大的点，如果x一样则找y更大的 ans[0] = xMaxPoint;//内部多边形x值最大的点即是内部空洞的互相可见点 outer.Clockwise(); inner.Counterclockwise();//确认点的排布顺序（外部顺时针，内部逆时针） Vector2 targetPoint = inner.points[xMaxPoint] + Vector2.right * 100000;//默认当前目标点在极远处 Vector2 crossPoint = Vector2.zero;//与线段的交点 int targetPointIndex = 0; for (int i = 0; i &lt; outer.points.Count; ++i) &#123; Vector2 point1 = outer.points[i]; Vector2 point2 = outer.points[i + 1 &gt;= outer.points.Count ? 0 : i + 1]; if (MMath.TryGetCrossWithXRay(inner.points[xMaxPoint], point1,point2, out Vector2 res))//获取向右发射的射线与目标线段的交点，如果没交点则返回false &#123; Vector2 target = Vector2.Distance(point1, inner.points[xMaxPoint]) &lt;= Vector2.Distance(point2, inner.points[xMaxPoint]) ? point1 : point2; int index = target.Equals(point1) ? i : (i + 1 &gt;= outer.points.Count ? 0 : i + 1); if (Vector2.Distance(target, inner.points[xMaxPoint]) &lt; Vector2.Distance(targetPoint, inner.points[xMaxPoint]))//如果小于之前的交点的距离 &#123; targetPoint = target; crossPoint = res; targetPointIndex = index; &#125; &#125; &#125; if (TryGetInnerPoints(new Triangle(inner.points[xMaxPoint], crossPoint, targetPoint, 0, 0), outer, out List&lt;int&gt; points) ) //如果三角形内有其他多边形的点 &#123; int index = 0; Vector2 v1 = (crossPoint - inner.points[xMaxPoint]).normalized; float minCos = Vector2.Dot(v1, (outer.points[points[0]] - inner.points[xMaxPoint]).normalized); for (int j = 0; j &lt; points.Count; ++j)//寻找与“原点”角度最小的点 &#123; Vector2 v2 = outer.points[points[j]] - inner.points[xMaxPoint]; float cos = Vector2.Dot(v1, v2.normalized); if (minCos &gt; cos) &#123; minCos = cos; ans[1] = points[j]; &#125; &#125; return ans; &#125; ans[1] = targetPointIndex; return ans;&#125; 至此，就能够将内多边形与外多边形合并成简单多边形了 然后再对这个简单多边形进行剖分 就可以得到剖分后的三角形们了。 使三角形支持A*寻路当然，目前的三角形还是不够完成寻路操作的。对于三角形的寻路一般使用的是A*算法，所以有几个关键参数需要补充到三角形上，那就是G和H，其中H这里设置为到目标的直线距离，由于此时的网格不是二维数组网格那样的规整网格，所以G的计算需要重新想方法，在这里则设置为三角形的从进入到出去所要移动的距离（进入边到离开边的中点之间的距离）。同时，还需要保存寻路中的父节点信息，可以直接保存为父三角形的ID。据此，创建NavTriangle继承于Triangle来实现。 123456789101112131415161718192021222324252627282930313233public class NavTriangle : Triangle&#123; // 寻路相关参数 public int traversalTimes; //是否已经遍历过，可能会有多次（多个Agent）所以不设为bool public int parentID; //父节点ID public bool isOpen; //是否打开 //评估相关 public double H; //H值 public double G; //G值 public int inWallIndex; //进入边 public int outWallIndex; //离开边 public NavTriangle():base() &#123; Reset(); &#125; /// &lt;summary&gt; /// 重置 /// &lt;/summary&gt; public void Reset() &#123; this.traversalTimes = -1; this.parentID = -1; this.isOpen = false; this.outWallIndex = -1; this.H = 0; this.G = 0; this.inWallIndex = -1; &#125;&#125; 然后在Triangle中添加public double[] neighborWallDistance;保存相邻两边的中点距离（0-1，1-2，2-0三边），在构造函数中进行计算。 到这，除了一些辅助性方法外，已经做好了A*的准备工作。","categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]},{"title":"自制NavMesh2D（一）","slug":"自制NavMesh2D（一）","date":"2020-11-02T12:56:23.000Z","updated":"2021-03-09T15:21:14.112Z","comments":true,"path":"2020/11/02/自制NavMesh2D（一）/","link":"","permalink":"https://github.com/Medemus/medemus.github.io/2020/11/02/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"图源：https://www.pixiv.net/artworks/84705376 自制NavMesh2D（一）网格构建三角形剖分三角形剖分的方法有好几种例如Delaunay三角剖分算法 123451.除了端点，三角形的边不包含其他任何点。2.除了在点上的连接，没有任何一条边是相交的。3.所有的面都是三角形，且所有三角形的合集是所有点集合的凸包。 但是这个方法里的几种算法都只适合于凸多边形，而真实情况则是会出现凹多边形以及空洞等情况。所以使用切耳算法能够更好的解决这些问题。 12345第一，找到一个耳点。第二，记录这个耳朵三角形，然后去掉这个耳朵点，在剩余的顶点中，继续回到第一步第三，直到剩下最后3个点形成一个三角形并记录下来，把所有记录的三角形拼接起来就形成了三角化网格。 上述步骤的几个名词解释: 123451.简单多边形是，所有顶点都是顺时针或者逆时针排列的顶点，每个顶点只连接两条边，边与边之间没有交叉的多边形，就叫做简单多边形。2.耳点，耳点的意思是，多边形中相邻的三个顶点V0,V1,V2形成的三角形里，不包含任何的其他顶点，并且如果V1点是凸点，即V0-V1的连线与V1-V2的连线之间形成的夹角小于180度，则认为V1是耳点。所以一个由4个顶点组成的多边形中，至少有2个耳点。3.耳朵三角形，三角形顶点中有耳点的就叫耳朵三角形。 如果出现了空洞的话: 1231，用外围的简单多边形上的点，连接‘洞’的简单多边形，因此为了保持所有点的一致性，‘洞’必须是与外围的多边形的点的顺序是相反的。即外围如果是逆时针的顺序，‘洞’则需要顺时针的顺序。2，在连接处，产生两个一模一样的点，即连接点。 下面以图片来做演示: 不包含洞与岛 首先初始的时候凸顶点集合C={0,1,3,4,6,9}，初始凹顶点集合R={2,5,7,8},初始的耳朵集合E={3,4,6,9}(三角形0,1,2中间有一个顶点7,所以1不是耳朵)。然后将顶点3去除后,2还是凹顶点,4还是耳朵顶点,所以这两集合不变。 接着移除4,5从凹顶点变成了凸顶点,并且成为了耳朵,所以将5从凹顶点移除,加入耳朵顶点集合。凹节点集合R={2,7,8},耳朵集合E={5,6,9} 移除5,此时2变成了凸顶点,但由于7在&lt;1,2,6&gt;中,所以不是耳朵,R={7,8}(移除了2)，耳朵集合E={6,9}(移除了5)。 此时2变成了耳朵,耳朵集合E={9,2}(添加2移除6)。 8变成了耳朵,0也从凸节点变成了耳朵,凹点集合R={7}，耳朵集合E={0,2,8}(添加8 ，添加0，移除9)。 耳朵列表变为E={2,8}(移除了0)。 只剩下了三个顶点,组成最后一个三角形。 含有洞与岛的情况 注意:外侧多边形的定点方形和内测岛洞的顶点方向必须是相反的。如果外侧的顶点是逆时针顺序，那么内测的顶点则必须是顺时针顺序。 首先将其构造成简单多边形,连接&lt;11,16&gt;,同时复制这两点连接&lt;19,18&gt;,两条边重合,方向相反,以此将该多边形构造成简单多边形,去除了空洞。 图中蓝色的顶点是互相可见的,在顶点数据结构不同的情况下,互相可见的顶点必须复制。每个数据结构存储当前点可能是凹点也可能是凸点。即使使用同一个坐标的两个点，也可能一个是凹点，一个是凸点，比如位于最下面的蓝色顶点11(18)。原始的顶点在最初的外多边形中是凹点，分割后在新的多边形中，V11与红色边相连，构成了一个凹点，与蓝色边相连构成另一个凸点。 1234567891011121314原始的外多边形顶点数据：&#123;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14&#125;原始的内多边形数据&#123;15,16,17&#125;分割后顶点V11被复制出V18，顶点V16复制出V19，这时候的简单多边形数据如下：&#123;0,1,2,3,4,5,6,7,8,9,10,11,16,17,15,19,18,12,13,14&#125;新的多边形即可以使用耳朵裁剪法切割。 寻找互相可见点上图中，11与16是一对相互可见点，但其实这样的点不止其一对，一个点来自外多边形，一个点来自内多边形，所以需要一个算法来寻找这样的多边形点。 以内多边形的最右点(X最大的点)为原点，向右作射线，如首先交于外多边形的顶点，则该顶点为相互可见点，而一般会相交于边上一点，设相交于I点，该边两端点离M(原点)最近的点就是相互可见点。 但有时候可能会出现被阻挡的情况。 此时有A、B、C三点在三角形MIP内部，获取这三点与M的连线与MI的夹角，取夹角最小的为互相可见点。 123456789101112131415算法总结如下:1、寻找内部多边形x周最大值的顶点M2、沿X周正方向，寻找最近的相交边&lt;Vi,Vi+1&gt;,让其焦点设置为I，构成X轴方向对M的最近可见点3、如果I是一个外部顶点，则M和I相互可见，算法执行结束4、如果I只是边上的一个点，寻找端点中x值片的一个，设置为P5、寻找位于P内的其他外多边形的可连接顶点。如果所有的顶点都在&lt;M,I,P&gt;之外，则M与P相互可见，反正结果6、如果有至少一个点位于三角形&lt;M,I,P&gt;内部，则寻找其中的一个顶点，计算其与x轴(1,0)的夹角，夹角最小的顶点R与M构成相互可见边，算法结束7、在这个算法中，有可能有多个顶点同事具有最小的角度，这种情况下，寻找距离M最近的一个点即可 含有多个岛洞的多边形此处的岛洞都仅被外多边形包含，彼此不存在嵌套岛洞的情形 内多边形I1没有任何一个顶点与外部多边形相互可见，多边形I0则拥有多个与外部多边形相互可见的点。因此，我们可以使用前面介绍的算法，首先把I0和外部多边形拆分，合并成为一个简单多边形，这样，新形成的外多边形则和I1构成了一件简单多边形，使用耳切法分割集合。 嵌套多边形内多边形也可能包含一些泪如岛洞的外多边形，类如嵌套。这样导致了嵌套多边形的树形结构。根节点是最外围的外多边形，子节点则是包含在当前最外多边形内部的内多边形。每一个孙子节点，则是构成直接被最外围多边形包含的内多边形的子树，每个多边形树可以按照宽度优先去遍历。 使用上面的获取互相可见边的方法，可以生成新的简单多边形，对每个内多边形都做这样的操作，完成最终的三角划分，以便获取最终的索引顺序，来代替最初的多边形顶点定义顺序。相比原始的值，这里可能需要复制一些顶点，以便被多个三角形使用。","categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]},{"title":"NavMesh","slug":"NavMesh","date":"2020-10-29T12:56:23.000Z","updated":"2021-03-09T15:21:46.747Z","comments":true,"path":"2020/10/29/NavMesh/","link":"","permalink":"https://github.com/Medemus/medemus.github.io/2020/10/29/NavMesh/","excerpt":"","text":"NavMeshNavMesh 生成 首先对地图进行栅格化（分成一个个小格），然后就可以根据栅格化的地图获取到内边缘 接下来对边缘进行简化首先找到两个点连线得到简化的边缘 然后找到距离该线最远的点，加入顶点集合中重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。 由于角色体型不同时，路径应该不同，在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。 进行空间的划分首先设置一个阈值，当两点间直线距离/两点边界距离小于该值时，进行区域分割。该过程可使用递归进行。完成分割后，每块区域作为图的一个节点，每两个点之间都可以通过简单的直线路径连通。可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。对于有空洞的地图，在进行边缘简化后，对每个空洞区域，找到其和地图边界点距离最近的点，连接起来作为边界。 动态障碍可在运行时，修改地图与动态障碍物重叠的节点数据。寻路Unity中使用的基础算法是A*。漏斗算法 使用A*之类的算法计算出从起点到终点所走过的多边形/三角形的集合。 使用漏斗算法，将多边形集合转换成最优路径。 首先计算出三角形列表中的邻接边列表，所谓邻接边就是两个三角形公用的边图中橙色边即邻接边，绿色为漏斗边。 将漏斗边移至下一条邻接边的两端，如果漏斗边的夹角变小或不变就算此次移动有效。 继续移动，如果出现了漏斗角的度数变成负数，例如右漏斗边移动到了左漏斗边的左侧，那么被盖过去的那条边的终点就成为了结果中的第一个点。同时将漏斗边的起点移到该点，构建出新漏斗。 如果遇到度数变大的情况，不动（虽然发生了移动但终点和起点一致）的那条边移动成功，导致度数变大的边移动失败（即其不发生移动）。 结束时，算法已经移动到了最后一条邻接边，但是从现在的漏斗底直接连一条线到终点肯定是不可行的。随后我们以终点一个点，当作一条两条端点相同的边。用它继续前进漏斗口。右边的漏斗边如果移动，会使漏斗口变大，因此不移动，左边的漏斗边移动，会盖过右边的漏斗边，因此右边的漏斗边终点成为了结果中的另一个点。 同样，以该点所在三角形的出邻接边重新构造漏斗，继续算法，很快就会发现漏斗口到终点，收到了最小，算法结束。","categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]}],"categories":[{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/categories/Navigation/"}],"tags":[{"name":"NavMesh","slug":"NavMesh","permalink":"https://github.com/Medemus/medemus.github.io/tags/NavMesh/"},{"name":"Navigation","slug":"Navigation","permalink":"https://github.com/Medemus/medemus.github.io/tags/Navigation/"}]}