<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>力扣每日一题 2020年10月31日</title>
    <link href="/2020/10/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202020%E5%B9%B410%E6%9C%8831%E6%97%A5/"/>
    <url>/2020/10/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%202020%E5%B9%B410%E6%9C%8831%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="力扣每日一题-2020年10月31日"><a href="#力扣每日一题-2020年10月31日" class="headerlink" title="力扣每日一题 2020年10月31日"></a>力扣每日一题 2020年10月31日</h1><h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="#381-O-1-时间插入、删除和获取随机元素-允许重复" class="headerlink" title="381. O(1) 时间插入、删除和获取随机元素 - 允许重复"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4><blockquote><p>从今天起打算记录一下每日一题，来督促自己学习，结果没想到第一天就来个困难呢（</p></blockquote><pre><code class="hljs reasonml">设计一个支持在平均 时间复杂度 <span class="hljs-constructor">O(1)</span> 下， 执行以下操作的数据结构。注意: 允许出现重复元素。insert(<span class="hljs-keyword">val</span>)：向集合中插入元素 <span class="hljs-keyword">val</span>。remove(<span class="hljs-keyword">val</span>)：当 <span class="hljs-keyword">val</span> 存在时，从集合中移除一个 <span class="hljs-keyword">val</span>。getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</code></pre><pre><code class="hljs yaml"><span class="hljs-string">示例:</span><span class="hljs-string">//</span> <span class="hljs-string">初始化一个空的集合。</span><span class="hljs-string">RandomizedCollection</span> <span class="hljs-string">collection</span> <span class="hljs-string">=</span> <span class="hljs-string">new</span> <span class="hljs-string">RandomizedCollection();</span><span class="hljs-string">//</span> <span class="hljs-string">向集合中插入</span> <span class="hljs-number">1</span> <span class="hljs-string">。返回</span> <span class="hljs-literal">true</span> <span class="hljs-string">表示集合不包含</span> <span class="hljs-number">1</span> <span class="hljs-string">。</span><span class="hljs-string">collection.insert(1);</span><span class="hljs-string">//</span> <span class="hljs-string">向集合中插入另一个</span> <span class="hljs-number">1</span> <span class="hljs-string">。返回</span> <span class="hljs-literal">false</span> <span class="hljs-string">表示集合包含</span> <span class="hljs-number">1</span> <span class="hljs-string">。集合现在包含</span> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] <span class="hljs-string">。</span><span class="hljs-string">collection.insert(1);</span><span class="hljs-string">//</span> <span class="hljs-string">向集合中插入</span> <span class="hljs-number">2</span> <span class="hljs-string">，返回</span> <span class="hljs-literal">true</span> <span class="hljs-string">。集合现在包含</span> [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-string">。</span><span class="hljs-string">collection.insert(2);</span><span class="hljs-string">//</span> <span class="hljs-string">getRandom</span> <span class="hljs-string">应当有</span> <span class="hljs-number">2</span><span class="hljs-string">/3</span> <span class="hljs-string">的概率返回</span> <span class="hljs-number">1</span> <span class="hljs-string">，1/3</span> <span class="hljs-string">的概率返回</span> <span class="hljs-number">2</span> <span class="hljs-string">。</span><span class="hljs-string">collection.getRandom();</span><span class="hljs-string">//</span> <span class="hljs-string">从集合中删除</span> <span class="hljs-number">1</span> <span class="hljs-string">，返回</span> <span class="hljs-literal">true</span> <span class="hljs-string">。集合现在包含</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-string">。</span><span class="hljs-string">collection.remove(1);</span><span class="hljs-string">//</span> <span class="hljs-string">getRandom</span> <span class="hljs-string">应有相同概率返回</span> <span class="hljs-number">1</span> <span class="hljs-string">和</span> <span class="hljs-number">2</span> <span class="hljs-string">。</span><span class="hljs-string">collection.getRandom();</span></code></pre><p>初看这题的第一反应就想到了哈希表（因为要求插入、查询、删除的平均时间复杂度在o(1)下），但一开始有一个没想通的就是允许重复然后随机获取概率与其数量相关。后来看到说用List维护数据，哈希表维护数据的Index，当删除时，将需要删除的数据与List最后一个数据交换，避免删除List的数据造成重新排列的问题，这样就可以在o(1)的时间内完成这三个操作了。</p><p>于是最后完成的代码为：</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedCollection</span>   &#123;       <span class="hljs-keyword">public</span> List&lt;<span class="hljs-built_in">int</span>&gt; values;       <span class="hljs-keyword">public</span> Dictionary&lt;<span class="hljs-built_in">int</span>, HashSet&lt;<span class="hljs-built_in">int</span>&gt;&gt; valuesIndex;       <span class="hljs-comment">/** Initialize your data structure here. */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RandomizedCollection</span>(<span class="hljs-params"></span>)</span> &#123;           values = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();           valuesIndex = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">int</span>, HashSet&lt;<span class="hljs-built_in">int</span>&gt;&gt;();       &#125;          <span class="hljs-comment">/** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Insert</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> val</span>)</span> &#123;           values.Add(val);           <span class="hljs-keyword">if</span> (valuesIndex.ContainsKey(val))           &#123;               valuesIndex[val].Add(values.Count - <span class="hljs-number">1</span>);               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           &#125;           <span class="hljs-keyword">else</span>           &#123;               valuesIndex[val] = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">int</span>&gt;();               valuesIndex[val].Add(values.Count - <span class="hljs-number">1</span>);               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;           &#125;       &#125;          <span class="hljs-comment">/** Removes a value from the collection. Returns true if the collection contained the specified element. */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Remove</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> val</span>)</span> &#123;          <span class="hljs-keyword">if</span> (!valuesIndex.ContainsKey(val))           &#123;               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           &#125;                      <span class="hljs-keyword">if</span> (val == values.Last())           &#123;               valuesIndex[val].Remove(values.Count - <span class="hljs-number">1</span>);               values.RemoveAt(values.Count - <span class="hljs-number">1</span>);               <span class="hljs-keyword">if</span> (valuesIndex[val].Count == <span class="hljs-number">0</span>)           &#123;               valuesIndex.Remove(val);           &#125;               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;           &#125;           <span class="hljs-built_in">int</span> index = valuesIndex[val].Last(); <span class="hljs-comment">//所要删的元素的index</span>           <span class="hljs-built_in">int</span> lastIndex = values.Count - <span class="hljs-number">1</span>;<span class="hljs-comment">//最后一个元素的index</span>           <span class="hljs-built_in">int</span> tmp = values[lastIndex];<span class="hljs-comment">//最后一个元素</span>                      valuesIndex[tmp].Remove(lastIndex);<span class="hljs-comment">//最后一个元素把index删掉</span>           valuesIndex[tmp].Add(index);<span class="hljs-comment">//最后一个元素添加所要删除的元素的index</span>           values[index] = tmp;<span class="hljs-comment">//将最后一个元素放到要删的元素处</span>           values.RemoveAt(lastIndex);<span class="hljs-comment">//删除数组最后一个</span>           valuesIndex[val].Remove(index);<span class="hljs-comment">//将删除的元素的index从其dic中删除</span>                      <span class="hljs-keyword">if</span> (valuesIndex[val].Count == <span class="hljs-number">0</span>)           &#123;               valuesIndex.Remove(val);           &#125;                      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;       &#125;          <span class="hljs-comment">/** Get a random element from the collection. */</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">GetRandom</span>(<span class="hljs-params"></span>)</span> &#123;           Random random = <span class="hljs-keyword">new</span> Random(Guid.NewGuid().GetHashCode());           <span class="hljs-keyword">return</span> values[random.Next(<span class="hljs-number">0</span>,values.Count)];       &#125;   &#125;</code></pre><p>其中随机数这块卡了我好久，一开始直接调用的<code> Random random = new Random();</code>结果由于时间间隔太短导致每次取得的随机值都一样，后来粗暴的将seed设成上方这样，勉强拿到了比较随机的值。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>每日一题</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NavMesh</title>
    <link href="/2020/10/29/NavMesh/"/>
    <url>/2020/10/29/NavMesh/</url>
    
    <content type="html"><![CDATA[<h1 id="NavMesh"><a href="#NavMesh" class="headerlink" title="NavMesh"></a>NavMesh</h1><p><a href="https://wo1fsea.github.io/2016/08/21/A_Quick_Introduction_to_NavMesh/">NavMesh</a></p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><ul><li>首先对地图进行栅格化（分成一个个小格），然后就可以根据栅格化的地图获取到内边缘<br><img src="/images/20201022141248234_23947.png"></li><li>接下来对边缘进行简化首先找到两个点连线得到简化的边缘<br><img src="/images/20201022142131618_27103.png"></li><li>然后找到距离该线最远的点，加入顶点集合中<br><img src="/images/20201022142424297_28453.png"><br>重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。</li><li>由于角色体型不同时，路径应该不同，在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。<br><img src="/images/20201022144128943_29308.png"><br><img src="/images/20201022144114158_15868.png"></li><li>进行空间的划分<br><img src="/images/20201022162123919_2043.png"><br>首先设置一个阈值，当<strong>两点间直线距离/两点边界距离</strong>小于该值时，进行区域分割。<br><img src="/images/20201022162635191_27753.png"><br>该过程可使用递归进行。<br>完成分割后，每块区域作为图的一个节点，每两个点之间都可以通过简单的直线路径连通。<br>可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。<br><img src="/images/20201022163352484_11008.png"><br>对于有空洞的地图，在进行边缘简化后，对每个空洞区域，找到其和地图边界点距离最近的点，连接起来作为边界。<br><img src="/images/20201022164056252_26253.png"></li><li>动态障碍<br>可在运行时，修改地图与动态障碍物重叠的节点数据。<br><img src="/images/20201022164332728_4957.png"><h2 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h2>Unity中使用的基础算法是A*。<h3 id="漏斗算法"><a href="#漏斗算法" class="headerlink" title="漏斗算法"></a>漏斗算法</h3></li><li>使用A*之类的算法计算出从起点到终点所走过的多边形/三角形的集合。</li><li>使用漏斗算法，将多边形集合转换成最优路径。<br><img src="/images/20201022165003280_24116.png"></li><li>首先计算出三角形列表中的邻接边列表，所谓邻接边就是两个三角形公用的边<br><img src="/images/20201022170130106_31434.png"><br>图中橙色边即邻接边，绿色为<strong>漏斗边</strong>。</li><li>将<strong>漏斗边</strong>移至下一条邻接边的两端，如果漏斗边的夹角变小或不变就算此次移动有效。<br><img src="/images/20201022170742425_6891.png"></li><li>继续移动，如果出现了漏斗角的度数变成负数，例如右漏斗边移动到了左漏斗边的左侧，那么被盖过去的那条边的终点就成为了结果中的第一个点。同时将漏斗边的起点移到该点，构建出新漏斗。<br><img src="/images/20201022171050194_20813.png"></li><li>如果遇到度数变大的情况，不动（虽然发生了移动但终点和起点一致）的那条边移动成功，导致度数变大的边移动失败（即其不发生移动）。<br><img src="/images/20201022171614258_16517.png"></li><li>结束时，算法已经移动到了最后一条邻接边，但是从现在的漏斗底直接连一条线到终点肯定是不可行的。随后我们以终点一个点，当作一条两条端点相同的边。用它继续前进漏斗口。右边的漏斗边如果移动，会使漏斗口变大，因此不移动，左边的漏斗边移动，会盖过右边的漏斗边，因此右边的漏斗边终点成为了结果中的另一个点。<br><img src="/images/20201022171731929_30643.png"></li><li>同样，以该点所在三角形的出邻接边重新构造漏斗，继续算法，很快就会发现漏斗口到终点，收到了最小，算法结束。<br><img src="/images/20201022171754374_20441.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NavMesh</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nav2D插件工作原理</title>
    <link href="/2020/10/29/Nav2D%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2020/10/29/Nav2D%E6%8F%92%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Nav2D插件工作原理"><a href="#Nav2D插件工作原理" class="headerlink" title="Nav2D插件工作原理"></a>Nav2D插件工作原理</h1><h2 id="大致概括"><a href="#大致概括" class="headerlink" title="大致概括"></a>大致概括</h2><p>该插件利用unity原生的navigation，对2d场景上的物体进行坐标转换建立对应的3d collider，然后调用navigation的bake进行navmesh的制作，也就是对unity原生navigation进行了一层套壳。<br>在寻路时，也是先建立2d对应的3d场景（collider、agent、obstacle等），将寻路目标点转换成三维坐标转递给agent，每帧将agent的坐标同步到2d中对应的物体。</p><h2 id="建立NavMesh"><a href="#建立NavMesh" class="headerlink" title="建立NavMesh"></a>建立NavMesh</h2><p>代码文件在editor中。<br>主要工作于其中的Navigation2D.cs中完成：</p><ul><li><code>BakeNavMesh2D()</code>中进行NavMesh的烘培。<br>首先根据2d中的静态collider建立对应的3d collider<pre><code class="hljs reasonml"><span class="hljs-comment">// create a temporary parent GameObject</span>        var obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GameObject()</span>;        <span class="hljs-comment">// find all static box colliders, add them to projection</span>        <span class="hljs-constructor">AddBoxCollider2Ds(<span class="hljs-params">obj</span>.<span class="hljs-params">transform</span>)</span>;        <span class="hljs-comment">// find all static circle colliders, add them to projection</span>        <span class="hljs-constructor">AddCircleCollider2Ds(<span class="hljs-params">obj</span>.<span class="hljs-params">transform</span>)</span>;        <span class="hljs-comment">// find all static polygon colliders, add them to projection</span>        <span class="hljs-constructor">AddPolygonCollider2Ds(<span class="hljs-params">obj</span>.<span class="hljs-params">transform</span>)</span>;        <span class="hljs-comment">// find all edge polygon colliders, add them to projection</span>        <span class="hljs-constructor">AddEdgeCollider2Ds(<span class="hljs-params">obj</span>.<span class="hljs-params">transform</span>)</span>;        <span class="hljs-comment">// find all tilemap colliders, add them to projection</span>#<span class="hljs-keyword">if</span> UNITY_2017_2_OR_NEWER        <span class="hljs-constructor">AddTilemapCollider2Ds(<span class="hljs-params">obj</span>.<span class="hljs-params">transform</span>)</span>;#endif<span class="hljs-comment">// min and max point from 2D colliders projected to 3D.</span>        <span class="hljs-comment">// (scanning through 3D colliders doesn&#x27;t work well because the polygon</span>        <span class="hljs-comment">//  GameObjects are pure meshes without colliders)</span>        var cols = GameObject.FindObjectsOfType&lt;Collider2D&gt;<span class="hljs-literal">()</span>;        <span class="hljs-keyword">if</span> (cols.Length &gt; <span class="hljs-number">0</span>)        &#123;            var min = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector2(Mathf.Infinity, Mathf.Infinity)</span>;            var max = -min;            foreach (var c <span class="hljs-keyword">in</span> cols)            &#123;                var minmax = NavMeshUtils2D.<span class="hljs-constructor">AdjustMinMax(<span class="hljs-params">c</span>, <span class="hljs-params">min</span>, <span class="hljs-params">max</span>)</span>;                min = minmax<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;                max = minmax<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;            &#125;</code></pre></li><li>建立地面<pre><code class="hljs maxima">// create ground (<span class="hljs-built_in">cube</span> instead of plane because it has unit size)            // (pos between <span class="hljs-built_in">min</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span>; scaled to fit <span class="hljs-built_in">min</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">max</span> * <span class="hljs-built_in">scale</span>)            // note: <span class="hljs-built_in">scale</span>.y=<span class="hljs-number">0</span> so that *navmeshExtends doesn&#x27;t make it too high            <span class="hljs-built_in">var</span> <span class="hljs-built_in">go</span> = GameObject.CreatePrimitive(PrimitiveType.Cube);            <span class="hljs-built_in">go</span>.name = <span class="hljs-string">&quot;Ground&quot;</span>; // <span class="hljs-keyword">for</span> debugging            <span class="hljs-built_in">go</span>.isStatic = <span class="hljs-literal">true</span>;            <span class="hljs-built_in">go</span>.<span class="hljs-built_in">transform</span>.parent = obj.<span class="hljs-built_in">transform</span>;            <span class="hljs-built_in">float</span> w = <span class="hljs-built_in">max</span>.x - <span class="hljs-built_in">min</span>.x;            <span class="hljs-built_in">float</span> h = <span class="hljs-built_in">max</span>.y - <span class="hljs-built_in">min</span>.y;            <span class="hljs-built_in">go</span>.<span class="hljs-built_in">transform</span>.<span class="hljs-built_in">position</span> = <span class="hljs-built_in">new</span> Vector3(<span class="hljs-built_in">min</span>.x + w/<span class="hljs-number">2</span>, -<span class="hljs-number">0.</span>5f, <span class="hljs-built_in">min</span>.y + h/<span class="hljs-number">2</span>);            <span class="hljs-built_in">go</span>.<span class="hljs-built_in">transform</span>.localScale = <span class="hljs-built_in">new</span> Vector3(w, <span class="hljs-number">0</span>, h) * navmeshExtends;</code></pre></li><li>调用Unity的NavMeshBuilder进行NavMesh生成<pre><code class="hljs reasonml"><span class="hljs-comment">// bake navmesh asynchronously, clear mesh</span>        UnityEditor.AI.NavMeshBuilder.<span class="hljs-constructor">BuildNavMeshAsync()</span>; <span class="hljs-comment">// Async causes weird results</span>        <span class="hljs-keyword">if</span> (gizmesh != null) gizmesh.<span class="hljs-constructor">Clear()</span>;        needsRebuild = <span class="hljs-literal">true</span>; <span class="hljs-comment">// rebuild as soon as async baking is finished</span>        <span class="hljs-comment">// delete the gameobjects now that the path was created</span>        GameObject.<span class="hljs-constructor">DestroyImmediate(<span class="hljs-params">obj</span>)</span>;</code></pre><h2 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h2>代码文件位于Plugins文件夹下<br>其中有<strong>NavMeshUtils2D</strong>、<strong>NavMesh2D</strong>是作为静态工具类在使用，主要功能是进行二维于三维坐标之间的转换。<br>主要代码位于<strong>NavMeshAgent2D.cs</strong>中。</li><li>初始化<br>根据输入的参数，生成在3d下的NavMeshAgent。<pre><code class="hljs sqf"><span class="hljs-comment">// create projection</span>        var go = GameObject.CreatePrimitive(PrimitiveType.Cylinder);        go.<span class="hljs-built_in">name</span> = <span class="hljs-string">&quot;NAVIGATION2D_AGENT&quot;</span>;        go.transform.<span class="hljs-built_in">position</span> = NavMeshUtils2D.ProjectTo3D(transform.<span class="hljs-built_in">position</span>); <span class="hljs-comment">// todo height 0.5 again?</span>        <span class="hljs-built_in">agent</span> = go.AddComponent&lt;NavMeshAgent&gt;();        rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();        collider2D = GetComponent&lt;Collider2D&gt;();        <span class="hljs-comment">// disable navmesh and collider (no collider for now...)</span>        Destroy(<span class="hljs-built_in">agent</span>.GetComponent&lt;Collider&gt;());        Destroy(<span class="hljs-built_in">agent</span>.GetComponent&lt;MeshRenderer&gt;());        <span class="hljs-comment">// pass serialized values once</span>        <span class="hljs-built_in">agent</span>.<span class="hljs-built_in">speed</span> = <span class="hljs-variable">_speed</span>;        <span class="hljs-built_in">agent</span>.angularSpeed = <span class="hljs-variable">_angularSpeed</span>;        <span class="hljs-built_in">agent</span>.acceleration = <span class="hljs-variable">_acceleration</span>;        <span class="hljs-built_in">agent</span>.stoppingDistance = <span class="hljs-variable">_stoppingDistance</span>;        <span class="hljs-built_in">agent</span>.autoBraking = <span class="hljs-variable">_autoBraking</span>;        <span class="hljs-built_in">agent</span>.radius = <span class="hljs-variable">_radius</span>;        <span class="hljs-built_in">agent</span>.obstacleAvoidanceType = <span class="hljs-variable">_quality</span>;        <span class="hljs-built_in">agent</span>.avoidancePriority = <span class="hljs-variable">_priority</span>;        <span class="hljs-built_in">agent</span>.autoRepath = <span class="hljs-variable">_autoRepath</span>;</code></pre></li><li>坐标转换<br>当选择2d平面上一点时，设置NavMeshAgent2Dd的destination，其会将值转换成三维坐标，赋值给该对象对应的agent。<pre><code class="hljs csharp"><span class="hljs-keyword">public</span> Vector2 destination    &#123;        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> NavMeshUtils2D.ProjectTo2D(agent.destination); &#125;        <span class="hljs-keyword">set</span> &#123; agent.destination = NavMeshUtils2D.ProjectTo3D(<span class="hljs-keyword">value</span>); &#125;    &#125;</code></pre>在<strong>Update</strong>、<strong>LateUpdate</strong>、<strong>FixedUpdate</strong>中，将3d空间中Agent的运行结果（位置），转换到2d赋值给对象。<pre><code class="hljs pgsql"><span class="hljs-type">void</span> <span class="hljs-keyword">Update</span>()    &#123;        // <span class="hljs-keyword">copy</span> position: <span class="hljs-keyword">transform</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">Update</span>, rigidbody <span class="hljs-keyword">in</span> FixedUpdate        <span class="hljs-keyword">if</span> (rigidbody2D == <span class="hljs-keyword">null</span> || rigidbody2D.isKinematic)            <span class="hljs-keyword">transform</span>.position = NavMeshUtils2D.ProjectTo2D(agent.<span class="hljs-keyword">transform</span>.position);        // stuck detection        <span class="hljs-keyword">if</span> (IsStuck())        &#123;            // stop agent movement, <span class="hljs-keyword">reset</span> it <span class="hljs-keyword">to</span> <span class="hljs-keyword">current</span> position            agent.ResetPath();            agent.<span class="hljs-keyword">transform</span>.position = NavMeshUtils2D.ProjectTo3D(<span class="hljs-keyword">transform</span>.position);            <span class="hljs-keyword">Debug</span>.Log(&quot;stopped agent because of collision in 2D plane&quot;);        &#125;    &#125;    <span class="hljs-type">void</span> LateUpdate()    &#123;        // <span class="hljs-keyword">copy</span> position again, maybe NavMeshAgent did something <span class="hljs-built_in">new</span>        <span class="hljs-keyword">if</span> (rigidbody2D == <span class="hljs-keyword">null</span> || rigidbody2D.isKinematic)            <span class="hljs-keyword">transform</span>.position = NavMeshUtils2D.ProjectTo2D(agent.<span class="hljs-keyword">transform</span>.position);    &#125;    <span class="hljs-type">void</span> FixedUpdate()    &#123;        // <span class="hljs-keyword">copy</span> position: <span class="hljs-keyword">transform</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">Update</span>, rigidbody <span class="hljs-keyword">in</span> FixedUpdate        <span class="hljs-keyword">if</span> (rigidbody2D != <span class="hljs-keyword">null</span> &amp;&amp; !rigidbody2D.isKinematic)            rigidbody2D.MovePosition(NavMeshUtils2D.ProjectTo2D(agent.<span class="hljs-keyword">transform</span>.position));    &#125;</code></pre></li><li>障碍物<br>原理与上方代码一致，根据2d物体建立对应的3d Obstacle，Update中进行位置转换，只不过由于是障碍物，所以是2d的坐标同步到3d空间中。<pre><code class="hljs reasonml">void <span class="hljs-constructor">Update()</span>    &#123;        <span class="hljs-comment">// copy properties to projection all the time</span>        <span class="hljs-comment">// (in case they are modified after creating it)</span>        obstacle.carving = carve;        obstacle.center = NavMeshUtils2D.<span class="hljs-constructor">ProjectTo3D(<span class="hljs-params">center</span>)</span>;        obstacle.size = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(<span class="hljs-params">size</span>.<span class="hljs-params">x</span>, 1, <span class="hljs-params">size</span>.<span class="hljs-params">y</span>)</span>;        <span class="hljs-comment">// scale and rotate to match scaled/rotated sprites center properly</span>        obstacle.transform.localScale = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vector3(<span class="hljs-params">transform</span>.<span class="hljs-params">localScale</span>.<span class="hljs-params">x</span>, 1, <span class="hljs-params">transform</span>.<span class="hljs-params">localScale</span>.<span class="hljs-params">y</span>)</span>;        obstacle.transform.rotation = Quaternion.<span class="hljs-constructor">Euler(NavMeshUtils2D.RotationTo3D(<span class="hljs-params">transform</span>.<span class="hljs-params">eulerAngles</span>)</span>);        <span class="hljs-comment">// project position to 3d</span>        obstacle.transform.position = NavMeshUtils2D.<span class="hljs-constructor">ProjectTo3D(<span class="hljs-params">transform</span>.<span class="hljs-params">position</span>)</span>;    &#125;</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿巴阿巴</title>
    <link href="/2020/10/28/%E9%98%BF%E5%B7%B4%E9%98%BF%E5%B7%B4/"/>
    <url>/2020/10/28/%E9%98%BF%E5%B7%B4%E9%98%BF%E5%B7%B4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
