<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自制NavMesh2D（三）</title>
    <link href="/2020/11/08/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/11/08/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图源：<a href="https://www.pixiv.net/artworks/85447522">https://www.pixiv.net/artworks/85447522</a></p></blockquote><h1 id="自制NavMesh2D（三）"><a href="#自制NavMesh2D（三）" class="headerlink" title="自制NavMesh2D（三）"></a>自制NavMesh2D（三）</h1><h2 id="对三角形进行A-寻路"><a href="#对三角形进行A-寻路" class="headerlink" title="对三角形进行A*寻路"></a>对三角形进行A*寻路</h2><p>在获得具体路径之前，需要知道走过了哪些三角形，只有知道需要经过哪些三角形才能进行接下来的路径规划，而一般这步操作是由A*算法来进行的。</p><p>在常见情况下，A*往往是对二维网格进行操作。</p><p><img src="/images/20201113113749257_3192.png" alt="A*"></p><p>那么如果要在不规则的三角形集合中进行A<em>寻路，看上去似乎有很大不同，但其实本质是一样的，在（二）中，为了支持三角形进行A</em>寻路，为其增添了一些参数，并规定了在三角形中的G与H的计算规则，这样就能按照常规的方法来进行A*寻路的操作了。</p><p>首先是要获取终点与终点所在的三角形：</p><pre><code class="hljs c#">NavTriangle startNavTriangle = <span class="hljs-literal">null</span>, endNavTriangle = <span class="hljs-literal">null</span>;<span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> triangle <span class="hljs-keyword">in</span> navMeshData)<span class="hljs-comment">//获取起始三角形与终点三角形</span>&#123;    <span class="hljs-keyword">if</span> (startNavTriangle == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">if</span> (MUtil.IsPointIn(start, triangle))            startNavTriangle = triangle;    <span class="hljs-keyword">if</span> (endNavTriangle == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">if</span> (MUtil.IsPointIn(end, triangle))            endNavTriangle = triangle;    <span class="hljs-keyword">if</span>(startNavTriangle != <span class="hljs-literal">null</span> &amp;&amp; endNavTriangle != <span class="hljs-literal">null</span>)        <span class="hljs-keyword">break</span>;&#125;</code></pre><p>进行A*相关操作：</p><pre><code class="hljs c#"><span class="hljs-comment">//A*寻路</span><span class="hljs-built_in">bool</span> isFound = <span class="hljs-literal">false</span>;<span class="hljs-built_in">int</span> traversalTimes = <span class="hljs-number">1</span>;List&lt;NavTriangle&gt; openList = <span class="hljs-keyword">new</span> List&lt;NavTriangle&gt;();   <span class="hljs-comment">//开放列表</span>List&lt;NavTriangle&gt; closeList = <span class="hljs-keyword">new</span> List&lt;NavTriangle&gt;();startNavTriangle.traversalTimes = traversalTimes;openList.Add(startNavTriangle);Debug.LogWarning(<span class="hljs-string">&quot;start:&quot;</span> + startNavTriangle.ID);<span class="hljs-built_in">int</span> tmp = <span class="hljs-number">10000</span>;<span class="hljs-keyword">while</span> (openList.Count &gt; <span class="hljs-number">0</span> &amp;&amp; tmp &gt; <span class="hljs-number">0</span>)&#123;    --tmp;    NavTriangle curNode;    curNode = openList[openList.Count - <span class="hljs-number">1</span>];    openList.Remove(curNode);    closeList.Add(curNode);    <span class="hljs-keyword">if</span> (curNode.ID == endNavTriangle.ID)    &#123;        isFound = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)    &#123;        <span class="hljs-built_in">int</span> index = curNode.neighborID[i];        NavTriangle neighboTriangle;        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>)        &#123;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-keyword">else</span>        &#123;            neighboTriangle = navMeshData[index];        &#125;        <span class="hljs-keyword">if</span> (neighboTriangle.groupID == startNavTriangle.groupID)        &#123;            <span class="hljs-keyword">if</span> (neighboTriangle.traversalTimes != traversalTimes)<span class="hljs-comment">//如果没有遍历过</span>            &#123;                neighboTriangle.traversalTimes = traversalTimes;                neighboTriangle.parentID = curNode.ID;<span class="hljs-comment">//将邻居的父节点设置为当前节点</span>                neighboTriangle.isOpen = <span class="hljs-literal">true</span>;                            neighboTriangle.CalcHeuristic(end);<span class="hljs-comment">//计算H</span>                neighboTriangle.G = curNode.G + curNode.GetCost(neighboTriangle.ID);<span class="hljs-comment">//计算G</span>                            openList.Add(neighboTriangle);<span class="hljs-comment">//加入openList</span>                openList.Sort(CompareTriWithFValue);<span class="hljs-comment">//根据F排序</span>                neighboTriangle.inWallIndex = curNode.ID;<span class="hljs-comment">//进入边为cur</span>            &#125;            <span class="hljs-keyword">else</span><span class="hljs-comment">//如果已在open中</span>            &#123;                <span class="hljs-keyword">if</span> (neighboTriangle.isOpen)                &#123;                    <span class="hljs-keyword">if</span> (neighboTriangle.G + neighboTriangle.GetCost(curNode.ID) &lt; curNode.G)<span class="hljs-comment">//如果当前到达邻居的G小于原来的G，则更新该邻居</span>                    &#123;                        Debug.Log(<span class="hljs-string">&quot;change:&quot;</span>+neighboTriangle.ID);                        curNode.G = neighboTriangle.G + neighboTriangle.GetCost(curNode.ID);                        curNode.parentID = neighboTriangle.ID;                        curNode.inWallIndex = neighboTriangle.ID;                    &#125;                &#125;                <span class="hljs-keyword">else</span>                &#123;                    neighboTriangle = <span class="hljs-literal">null</span>;                    <span class="hljs-keyword">continue</span>;                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">//遍历</span></code></pre><p>完成上述操作后即可在closeList中通过每个三角形的父节点获取完整的三角形列表。</p><p>测试，绿色点为起点，黄色为终点：</p><p><img src="/images/20201113163714578_30444.png" alt="获取三角形路径"></p><h2 id="计算路径"><a href="#计算路径" class="headerlink" title="计算路径"></a>计算路径</h2><p>在有了三角形后，就可以将其转换为具体的路径了。</p><p><img src="/images/20201022165003280_24116.png" alt="转换为具体的路径"></p><p>通过计算拐点获得路径上的路径点，再将这些路径点连接起来便是所需要的路径了。</p><p>所以这一步的关键操作就在于如何获取拐点。<a href="https://medemus.github.io/2020/10/29/NavMesh/">NavMesh</a></p><p>设计一个方法，用来获取<strong>下一个拐点</strong>：</p><p>所需要的相关信息：</p><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetNextWayPoint</span>(<span class="hljs-params">Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> curIndex</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">var</span> tri = pathList[curIndex];<span class="hljs-comment">//当前路径点所在的三角形</span>    <span class="hljs-keyword">var</span> outLine = tri.GetLineByIndex(tri.outWallIndex);<span class="hljs-comment">//获取当前三角形的离开边</span>    <span class="hljs-built_in">int</span> lastIndex1 = curIndex;<span class="hljs-comment">//当前左侧那条边的所在三角形的index</span>    <span class="hljs-built_in">int</span> lastIndex2 = curIndex;<span class="hljs-comment">//当前右侧那条边的所在三角形的index</span>    Line l1 = <span class="hljs-keyword">new</span> Line(way,outLine.start);<span class="hljs-comment">//右侧那条边，路径点-&gt;离开边的起点</span>    Line l2 = <span class="hljs-keyword">new</span> Line(way,outLine.end);<span class="hljs-comment">//左侧那条边，路径点-&gt;离开边的终点</span>    Vector2 targetPoint1, targetPoint2;<span class="hljs-comment">//下一个离开边的起点和终点（两条边下一个到达的位置）</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span>········</span>&#125;</code></pre><p>开始遍历：</p><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetNextWayPoint</span>(<span class="hljs-params">Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> curIndex</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment"><span class="hljs-doctag">///</span>········</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = curIndex + <span class="hljs-number">1</span>; i &lt; pathList.Count; ++i)<span class="hljs-comment">//从三角形列表的下一个开始遍历</span>    &#123;        tri = pathList[i];        outLine = tri.GetLineByIndex(tri.outWallIndex);<span class="hljs-comment">//下一个三角形的离开边</span>                <span class="hljs-keyword">if</span> (i == pathList.Count - <span class="hljs-number">1</span>)        &#123;            targetPoint1 = targetPoint2 = end;<span class="hljs-comment">//如果已经到了最后一个三角形，直接指向终点</span>        &#125;        <span class="hljs-keyword">else</span>        &#123;            targetPoint1 = outLine.start;            targetPoint2 = outLine.end;        &#125;    <span class="hljs-comment"><span class="hljs-doctag">///</span>········</span>    &#125;&#125;</code></pre><p>遍历时具体的判定：</p><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> Vector2 <span class="hljs-title">GetNextWayPoint</span>(<span class="hljs-params">Vector2 way,List&lt;NavTriangle&gt; pathList,Vector2 end,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> curIndex</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-comment"><span class="hljs-doctag">///</span>········</span>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = curIndex + <span class="hljs-number">1</span>; i &lt; pathList.Count; ++i)<span class="hljs-comment">//从三角形列表的下一个开始遍历</span>    &#123;    <span class="hljs-comment"><span class="hljs-doctag">///</span>········</span>        <span class="hljs-keyword">if</span> (!MMath.IsEqual(targetPoint1, l1.end))<span class="hljs-comment">//如果移动到的下一个边的点与当前点一样的话就不需要移动</span>        &#123;            <span class="hljs-keyword">if</span> (l2.ClassifyPoint(targetPoint1) == PointSide.LEFT_SIDE)<span class="hljs-comment">//如果右侧边的目标点在左侧边的左侧（代表漏斗角的度数变成负数）</span>            &#123;            <span class="hljs-comment">//左侧边的当前点就是拐点</span>                curIndex = lastIndex1;                Vector2 nextPoint = l2.end;                                <span class="hljs-keyword">return</span> nextPoint;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1.ClassifyPoint(targetPoint1) != PointSide.RIGHT_SIDE)<span class="hljs-comment">//如果右侧边的目标点没有在其右侧（角度没有变大）</span>            &#123;            <span class="hljs-comment">//正常移动</span>                lastIndex1 = i;                l1.end = targetPoint1;            &#125;        &#125;                <span class="hljs-keyword">if</span> (!MMath.IsEqual(targetPoint2, l2.end))<span class="hljs-comment">//如果移动到的下一个边的点与当前点一样的话就不需要移动</span>        &#123;            <span class="hljs-comment">/*Debug.DrawLine(l2.start,targetPoint2);*/</span>            <span class="hljs-keyword">if</span> (l1.ClassifyPoint(targetPoint2) == PointSide.RIGHT_SIDE)<span class="hljs-comment">//如果左侧边的目标点在右侧边的右侧（代表漏斗角的度数变成负数）</span>            &#123;                <span class="hljs-comment">//右侧边的当前点就是拐点</span>                Vector2 nextPoint = l1.end;                curIndex = lastIndex2;                <span class="hljs-keyword">return</span> nextPoint;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2.ClassifyPoint(targetPoint2) != PointSide.LEFT_SIDE)<span class="hljs-comment">//如果左侧边的目标点没有在其左侧（角度没有变大）</span>            &#123;            <span class="hljs-comment">//正常移动</span>                lastIndex2 = i;                l2.end = targetPoint2;            &#125;        &#125;    &#125;    Vector2 wayPoint = end;    curIndex = pathList.Count - <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> wayPoint;&#125;</code></pre><p>通过这样，就能够获取到下一个拐点，然后再将该拐点的所在三角形作为当前三角形，获取下一个拐点（路径点），直到路径点为终点，结束寻找。</p><pre><code class="hljs c#"><span class="hljs-keyword">var</span> point = start;wayPoints.Add(point);<span class="hljs-built_in">int</span> curIndex = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (!(point == end))<span class="hljs-comment">//如果获取到的拐点（路径点）不是终点</span>&#123;    point = GetNextWayPoint(point, pathList, end, <span class="hljs-keyword">ref</span> curIndex);<span class="hljs-comment">//获取下一个拐点</span>    <span class="hljs-keyword">if</span> (point == <span class="hljs-literal">null</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    wayPoints.Add(point);<span class="hljs-comment">//将获取到的点添加进路径点列表</span>&#125;</code></pre><p>测试：</p><p><img src="/images/20201113163930648_16202.png" alt="获得路径"></p><p><img src="/images/20201113164433300_5105.gif" alt="获得路径"></p>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NavMesh</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制NavMesh2D（二）</title>
    <link href="/2020/11/04/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/11/04/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图源：<a href="https://www.pixiv.net/artworks/85217491">https://www.pixiv.net/artworks/85217491</a></p></blockquote><h1 id="自制NavMesh2D（二）"><a href="#自制NavMesh2D（二）" class="headerlink" title="自制NavMesh2D（二）"></a>自制NavMesh2D（二）</h1><p>根据上面的学习，能够大致了解一个NavMesh2D的制作流程了，所以接下来就是上手实践。<br>在此参考了<a href="http://www.luzexi.com/2013/10/06/Unity3D%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1NavMesh%E5%AF%BB%E8%B7%AF">Unity3D架构设计NavMesh寻路</a>的设计。</p><h2 id="根据顶点生成多边形"><a href="#根据顶点生成多边形" class="headerlink" title="根据顶点生成多边形"></a>根据顶点生成多边形</h2><p>由于所制作的为纯2D，是可以由sprite的顶点信息获取边缘信息的，所以在此我想先跳过光栅化的阶段，先行从多边形生成开始。</p><p>在此需要制定多边形类的信息，在此设定的多边形类的参数为List&lt;Vector&gt;类型的顶点列表。</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Polygon</span>    &#123;        <span class="hljs-keyword">public</span> List&lt;Vector2&gt; points;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Polygon</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>        &#123;            points = <span class="hljs-keyword">new</span> List&lt;Vector2&gt;();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Polygon</span>(<span class="hljs-params">List&lt;Vector2&gt; vertices</span>)</span><span class="hljs-function"></span>        &#123;            points = <span class="hljs-keyword">new</span> List&lt;Vector2&gt;();            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> vertex <span class="hljs-keyword">in</span> vertices)            &#123;                points.Add(vertex);            &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Polygon</span>(<span class="hljs-params">Vector2[] vertices</span>)</span><span class="hljs-function"></span>        &#123;            points = <span class="hljs-keyword">new</span> List&lt;Vector2&gt;();            <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> vertex <span class="hljs-keyword">in</span> vertices)            &#123;                points.Add(vertex);            &#125;        &#125;    &#125;</code></pre><p>有了点就该有线了，那么线应该就是由一个<strong>起点</strong>与一个<strong>终点</strong>所组成。</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Line</span>    &#123;        <span class="hljs-keyword">public</span> Vector2 start;        <span class="hljs-keyword">public</span> Vector2 end;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Line</span>(<span class="hljs-params">Vector2 start, Vector2 end</span>)</span><span class="hljs-function"></span>        &#123;            <span class="hljs-keyword">this</span>.start = start;            <span class="hljs-keyword">this</span>.end = end;        &#125;    &#125;</code></pre><p>然后只要规定一个连线顺序（在这我规定的是外多边形为顺时针，内多边形为逆时针），就可以描述一个多边形了。</p><p>用Gizmo来绘制测试一下</p><p><img src="/images/20201110173849572_32046.png" alt="由点组成多边形"></p><h2 id="对单个多边形进行三角形剖分"><a href="#对单个多边形进行三角形剖分" class="headerlink" title="对单个多边形进行三角形剖分"></a>对单个多边形进行三角形剖分</h2><p>多边形有了后，就该着手进行剖分了，先不考虑存在空洞、相交的情况。</p><p>为了进行剖分，首先需要构建三角形类，三角形的组成和多边形类似，但为了进行一些操作所以需要更多的参数。</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>    &#123;        <span class="hljs-keyword">public</span> Vector2[] points;<span class="hljs-comment">//顶点列表</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID;<span class="hljs-comment">//每个三角形的ID</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>[] neighborID;<span class="hljs-comment">//三角形邻居节点ID</span>        <span class="hljs-keyword">public</span> Vector2 center;<span class="hljs-comment">//中心点</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Triangle</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>        &#123;            points = <span class="hljs-keyword">new</span> Vector2[<span class="hljs-number">3</span>];            neighborID = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span> &#125;;            center = Vector2.zero;        &#125;             <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Triangle</span>(<span class="hljs-params">Vector2 pos1,Vector2 pos2,Vector2 pos3,<span class="hljs-built_in">int</span> id</span>)</span><span class="hljs-function"></span>        &#123;            points = <span class="hljs-keyword">new</span>[] &#123;pos1, pos2, pos3&#125;;            ID = id;            neighborID = <span class="hljs-keyword">new</span>[] &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;            center.x = (points[<span class="hljs-number">0</span>].x + points[<span class="hljs-number">1</span>].x + points[<span class="hljs-number">2</span>].x) / <span class="hljs-number">3</span>;            center.y = (points[<span class="hljs-number">0</span>].y + points[<span class="hljs-number">1</span>].y + points[<span class="hljs-number">2</span>].y) / <span class="hljs-number">3</span>;        &#125;    &#125;</code></pre><p>在剖分前，还需要几个工具类进行辅助操作。</p><p>在工具类Util中，添加以下方法：</p><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 获取多边形在三角形内部的点</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryGetInnerPoints</span>(<span class="hljs-params">Triangle triangle,Polygon polygon,<span class="hljs-keyword">out</span> List&lt;<span class="hljs-built_in">int</span>&gt; res</span>)</span><span class="hljs-function"></span>&#123;    res = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();    List&lt;Vector2&gt; points = polygon.points;    HashSet&lt;Vector2&gt; trianglePoints = <span class="hljs-keyword">new</span> HashSet&lt;Vector2&gt;(triangle.points);    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; points.Count; i++)    &#123;        <span class="hljs-keyword">if</span> (!trianglePoints.Contains(points[i]))        &#123;            <span class="hljs-keyword">if</span> (MUtil.IsPointIn(points[i], triangle))<span class="hljs-comment">//是否有点在三角形内部</span>            &#123;                res.Add(i);            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (res.Count &gt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 指定点是否在三角形中</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsPointIn</span>(<span class="hljs-params">Vector2 point,Triangle triangle</span>)</span><span class="hljs-function"></span>&#123;    Vector3 AB = triangle.points[<span class="hljs-number">1</span>] - triangle.points[<span class="hljs-number">0</span>];    Vector3 AC = triangle.points[<span class="hljs-number">2</span>] - triangle.points[<span class="hljs-number">0</span>];    Vector3 AP = point - triangle.points[<span class="hljs-number">0</span>];    <span class="hljs-built_in">float</span> ABAB = Vector3.Dot(AB, AB);    <span class="hljs-built_in">float</span> ABAC = Vector3.Dot(AB, AC);    <span class="hljs-built_in">float</span> ABAP = Vector3.Dot(AB, AP);    <span class="hljs-built_in">float</span> ACAC = Vector3.Dot(AC, AC);    <span class="hljs-built_in">float</span> ACAP = Vector3.Dot(AC, AP);    <span class="hljs-built_in">float</span> inverDeno = <span class="hljs-number">1</span> / (ABAB * ACAC - ABAC * ABAC);    <span class="hljs-built_in">float</span> u = (ACAC * ABAP - ABAC * ACAP) * inverDeno;    <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span> || u &gt; <span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-built_in">float</span> v = (ABAB * ACAP - ABAC * ABAP) * inverDeno;    <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span> || v &gt; <span class="hljs-number">1</span>)    &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> u + v &lt;= <span class="hljs-number">1</span>;&#125;</code></pre><p>在三角形类中，添加方法：</p><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 获取三角形的指定边</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;index&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;returns&gt;</span><span class="hljs-doctag">&lt;/returns&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> Line <span class="hljs-title">GetLineByIndex</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> index</span>)</span><span class="hljs-function"></span>&#123;    Line line;    <span class="hljs-keyword">switch</span> (index)    &#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            line = <span class="hljs-keyword">new</span> Line(<span class="hljs-keyword">this</span>.points[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.points[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            line = <span class="hljs-keyword">new</span> Line(<span class="hljs-keyword">this</span>.points[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.points[<span class="hljs-number">2</span>]);            <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            line = <span class="hljs-keyword">new</span> Line(<span class="hljs-keyword">this</span>.points[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.points[<span class="hljs-number">0</span>]);            <span class="hljs-keyword">break</span>;        <span class="hljs-literal">default</span>:            line = <span class="hljs-keyword">new</span> Line(<span class="hljs-keyword">this</span>.points[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.points[<span class="hljs-number">1</span>]);            <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-keyword">return</span> line;&#125;</code></pre><p>为了获取三角形之间的关系，所以需要有</p><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 获取与指定三角形相邻的边</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryGetNeighbor</span>(<span class="hljs-params">Triangle triangle,<span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> res</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)        &#123;            <span class="hljs-keyword">if</span> (GetLineByIndex(i).Equals(triangle.GetLineByIndex(j)))            &#123;                res = i;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;    res = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;</code></pre><p>由此就可以进行接下来的剖分操作了。</p><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 进行切耳三角剖分</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Triangle&gt; <span class="hljs-title">EarCliping</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>&#123;    Clockwise();<span class="hljs-comment">//进行一次顺时针排序，以保证顺序</span>    List&lt;Triangle&gt; res = <span class="hljs-keyword">new</span> List&lt;Triangle&gt;();    List&lt;Vector2&gt; pointsTmp = <span class="hljs-keyword">new</span> List&lt;Vector2&gt;(points);    <span class="hljs-built_in">int</span> tmp = <span class="hljs-number">10000</span>;<span class="hljs-comment">//避免出现错误导致死循环死机而设置的最大循环上限数</span>    <span class="hljs-built_in">int</span> id = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (pointsTmp.Count &gt; <span class="hljs-number">3</span> &amp;&amp; tmp &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//当未剖分的顶点在三个以上时</span>    &#123;        tmp--;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; pointsTmp.Count; ++i)        &#123;            Triangle triangle = <span class="hljs-keyword">new</span> Triangle(pointsTmp[i - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span> ? pointsTmp.Count - <span class="hljs-number">1</span>:i<span class="hljs-number">-1</span>], pointsTmp[i],pointsTmp[i + <span class="hljs-number">1</span> &gt;= pointsTmp.Count ? <span class="hljs-number">0</span> : i + <span class="hljs-number">1</span>],<span class="hljs-number">0</span>);<span class="hljs-comment">//以i为中间顶点设置三角形</span>                        <span class="hljs-keyword">if</span>(triangle.GetLineByIndex(<span class="hljs-number">0</span>).ClassifyPoint(triangle.center) != PointSide.LEFT_SIDE)<span class="hljs-comment">//如果构成的三角形的中心不在线的内侧，就代表这是个凹点</span>                <span class="hljs-keyword">continue</span>;            <span class="hljs-keyword">if</span> (!MUtil.TryGetInnerPoints(triangle,<span class="hljs-keyword">this</span>, <span class="hljs-keyword">out</span> List&lt;<span class="hljs-built_in">int</span>&gt; inners))<span class="hljs-comment">//如果这个三角形内没有其他点，那就是耳朵</span>            &#123;                triangle.ID = id;                ++id;                res.Add(triangle);<span class="hljs-comment">//添加这个耳朵三角形</span>                pointsTmp.RemoveAt(i);<span class="hljs-comment">//从原多边形中裁去</span>                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    Triangle last = <span class="hljs-keyword">new</span> Triangle(pointsTmp[<span class="hljs-number">0</span>],pointsTmp[<span class="hljs-number">1</span>],pointsTmp[<span class="hljs-number">2</span>],id);<span class="hljs-comment">//将最后三个顶点组成三角形</span>    res.Add(last);    <span class="hljs-comment">/*for (int i = 0; i &lt; res.Count; i++)</span><span class="hljs-comment">    &#123;</span><span class="hljs-comment">        var tri = res[i];</span><span class="hljs-comment">        for (int j = 0; j &lt; res.Count; j++)</span><span class="hljs-comment">        &#123;</span><span class="hljs-comment">            var triNext = res[j];</span><span class="hljs-comment">            if(tri.ID == triNext.ID)</span><span class="hljs-comment">                continue;</span><span class="hljs-comment">            if (tri.TryGetNeighbor(triNext, out int index))</span><span class="hljs-comment">            &#123;</span><span class="hljs-comment">                tri.SetNeighbor(index,triNext.ID);</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">            </span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">    &#125;*/</span>    MUtil.FindNeiborgh(res);<span class="hljs-comment">//将上面查找并设置邻居的代码封装到工具类中了</span>    <span class="hljs-keyword">return</span> res;&#125;</code></pre><p>进行测试，现在已经可以获得剖分后的三角形了</p><p><img src="/images/20201110173810551_16904.png"></p><h2 id="对内部有空洞的多边形进行剖分"><a href="#对内部有空洞的多边形进行剖分" class="headerlink" title="对内部有空洞的多边形进行剖分"></a>对内部有空洞的多边形进行剖分</h2><p>下一步就是如果内部存在空洞的情况了，在这先只考虑简单情况，即不出现套娃型空洞。<br>如图所示：</p><p><img src="/images/20201110174354239_9305.png" alt="内部有空洞（红色）"></p><p>那么需要做的就是先将内部空洞多边形与外部合并成简单多边形，此处则需要寻找到<strong>互相可见点</strong>。</p><pre><code class="hljs c#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><span class="hljs-comment"><span class="hljs-doctag">///</span> 寻找互相可见点</span><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span>[] <span class="hljs-title">FindVisiblePoint</span>(<span class="hljs-params">Polygon outer, Polygon inner</span>)</span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">int</span>[] ans = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>];<span class="hljs-comment">//0为内部空洞的互相可见点的index，1为外部多边形的</span>    <span class="hljs-keyword">var</span> xMaxPoint = inner.GetXMaxPointIndex();<span class="hljs-comment">//遍历寻找内部多边形x值最大的点，如果x一样则找y更大的</span>    ans[<span class="hljs-number">0</span>] = xMaxPoint;<span class="hljs-comment">//内部多边形x值最大的点即是内部空洞的互相可见点</span>    outer.Clockwise();    inner.Counterclockwise();<span class="hljs-comment">//确认点的排布顺序（外部顺时针，内部逆时针）</span>    Vector2 targetPoint = inner.points[xMaxPoint] + Vector2.right * <span class="hljs-number">100000</span>;<span class="hljs-comment">//默认当前目标点在极远处</span>    Vector2 crossPoint = Vector2.zero;<span class="hljs-comment">//与线段的交点</span>    <span class="hljs-built_in">int</span> targetPointIndex = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; outer.points.Count; ++i)    &#123;        Vector2 point1 = outer.points[i];        Vector2 point2 = outer.points[i + <span class="hljs-number">1</span> &gt;= outer.points.Count ? <span class="hljs-number">0</span> : i + <span class="hljs-number">1</span>];        <span class="hljs-keyword">if</span> (MMath.TryGetCrossWithXRay(inner.points[xMaxPoint], point1,point2, <span class="hljs-keyword">out</span> Vector2 res))<span class="hljs-comment">//获取向右发射的射线与目标线段的交点，如果没交点则返回false</span>        &#123;            Vector2 target = Vector2.Distance(point1, inner.points[xMaxPoint]) &lt;= Vector2.Distance(point2, inner.points[xMaxPoint]) ? point1 : point2;            <span class="hljs-built_in">int</span> index = target.Equals(point1) ? i : (i + <span class="hljs-number">1</span> &gt;= outer.points.Count ? <span class="hljs-number">0</span> : i + <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (Vector2.Distance(target, inner.points[xMaxPoint]) &lt; Vector2.Distance(targetPoint, inner.points[xMaxPoint]))<span class="hljs-comment">//如果小于之前的交点的距离</span>            &#123;                targetPoint = target;                crossPoint = res;                targetPointIndex = index;            &#125;                    &#125;    &#125;    <span class="hljs-keyword">if</span> (TryGetInnerPoints(<span class="hljs-keyword">new</span> Triangle(inner.points[xMaxPoint], crossPoint, targetPoint, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), outer, <span class="hljs-keyword">out</span> List&lt;<span class="hljs-built_in">int</span>&gt; points)    ) <span class="hljs-comment">//如果三角形内有其他多边形的点</span>    &#123;        <span class="hljs-built_in">int</span> index = <span class="hljs-number">0</span>;        Vector2 v1 = (crossPoint - inner.points[xMaxPoint]).normalized;        <span class="hljs-built_in">float</span> minCos = Vector2.Dot(v1, (outer.points[points[<span class="hljs-number">0</span>]] - inner.points[xMaxPoint]).normalized);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; points.Count; ++j)<span class="hljs-comment">//寻找与“原点”角度最小的点</span>        &#123;            Vector2 v2 = outer.points[points[j]] - inner.points[xMaxPoint];            <span class="hljs-built_in">float</span> cos = Vector2.Dot(v1, v2.normalized);            <span class="hljs-keyword">if</span> (minCos &gt; cos)            &#123;                minCos = cos;                ans[<span class="hljs-number">1</span>] = points[j];            &#125;        &#125;                <span class="hljs-keyword">return</span> ans;    &#125;    ans[<span class="hljs-number">1</span>] = targetPointIndex;    <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>至此，就能够将内多边形与外多边形合并成简单多边形了</p><p><img src="/images/20201111104622012_23773.png" alt="合并内外多边形"></p><p>然后再对这个简单多边形进行剖分</p><p><img src="/images/20201111104739073_9002.png" alt="三角剖分"></p><p>就可以得到剖分后的三角形们了。</p><h2 id="使三角形支持A-寻路"><a href="#使三角形支持A-寻路" class="headerlink" title="使三角形支持A*寻路"></a>使三角形支持A*寻路</h2><p>当然，目前的三角形还是不够完成寻路操作的。对于三角形的寻路一般使用的是A*算法，所以有几个关键参数需要补充到三角形上，那就是<strong>G</strong>和<strong>H</strong>，其中<strong>H这里设置为到目标的直线距离</strong>，由于此时的网格不是二维数组网格那样的规整网格，所以G的计算需要重新想方法，在这里则<strong>设置为三角形的从进入到出去所要移动的距离（进入边到离开边的中点之间的距离）</strong>。<br>同时，还需要保存寻路中的父节点信息，可以直接保存为父三角形的ID。<br>据此，创建NavTriangle继承于Triangle来实现。</p><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NavTriangle</span> : <span class="hljs-title">Triangle</span>&#123;    <span class="hljs-comment">// 寻路相关参数</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> traversalTimes;   <span class="hljs-comment">//是否已经遍历过，可能会有多次（多个Agent）所以不设为bool</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> parentID;    <span class="hljs-comment">//父节点ID</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> isOpen;     <span class="hljs-comment">//是否打开</span>    <span class="hljs-comment">//评估相关</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> H;   <span class="hljs-comment">//H值</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> G;   <span class="hljs-comment">//G值</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> inWallIndex; <span class="hljs-comment">//进入边</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> outWallIndex; <span class="hljs-comment">//离开边</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NavTriangle</span>(<span class="hljs-params"></span>):<span class="hljs-title">base</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>    &#123;        Reset();    &#125;    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> 重置</span>    <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>(<span class="hljs-params"></span>)</span><span class="hljs-function"></span>    &#123;        <span class="hljs-keyword">this</span>.traversalTimes = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">this</span>.parentID = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">this</span>.isOpen = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">this</span>.outWallIndex = <span class="hljs-number">-1</span>;        <span class="hljs-keyword">this</span>.H = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.G = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.inWallIndex = <span class="hljs-number">-1</span>;    &#125;&#125;</code></pre><p>然后在Triangle中添加<code>public double[] neighborWallDistance;</code>保存相邻两边的中点距离（0-1，1-2，2-0三边），在构造函数中进行计算。</p><p>到这，除了一些辅助性方法外，已经做好了A*的准备工作。</p>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NavMesh</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自制NavMesh2D（一）</title>
    <link href="/2020/11/02/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/11/02/%E8%87%AA%E5%88%B6NavMesh2D%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图源：<a href="https://www.pixiv.net/artworks/84705376">https://www.pixiv.net/artworks/84705376</a></p></blockquote><h1 id="自制NavMesh2D（一）"><a href="#自制NavMesh2D（一）" class="headerlink" title="自制NavMesh2D（一）"></a>自制NavMesh2D（一）</h1><h2 id="网格构建"><a href="#网格构建" class="headerlink" title="网格构建"></a>网格构建</h2><h3 id="三角形剖分"><a href="#三角形剖分" class="headerlink" title="三角形剖分"></a>三角形剖分</h3><p>三角形剖分的方法有好几种例如<strong>Delaunay三角剖分算法</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>除了端点，三角形的边不包含其他任何点。<span class="hljs-number">2.</span>除了在点上的连接，没有任何一条边是相交的。<span class="hljs-number">3.</span>所有的面都是三角形，且所有三角形的合集是所有点集合的凸包。</code></pre><p>但是这个方法里的几种算法都只适合于凸多边形，而真实情况则是会出现凹多边形以及空洞等情况。<br>所以使用<strong>切耳算法</strong>能够更好的解决这些问题。</p><pre><code class="hljs angelscript">第一，找到一个耳点。第二，记录这个耳朵三角形，然后去掉这个耳朵点，在剩余的顶点中，继续回到第一步第三，直到剩下最后<span class="hljs-number">3</span>个点形成一个三角形并记录下来，把所有记录的三角形拼接起来就形成了三角化网格。</code></pre><p>上述步骤的几个名词解释:</p><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.简单多边形是，所有顶点都是顺时针或者逆时针排列的顶点，每个顶点只连接两条边，边与边之间没有交叉的多边形，就叫做简单多边形。<span class="hljs-attribute">2</span>.耳点，耳点的意思是，多边形中相邻的三个顶点V<span class="hljs-number">0</span>,V<span class="hljs-number">1</span>,V<span class="hljs-number">2</span>形成的三角形里，不包含任何的其他顶点，并且如果V<span class="hljs-number">1</span>点是凸点，即V<span class="hljs-number">0</span>-V<span class="hljs-number">1</span>的连线与V<span class="hljs-number">1</span>-V<span class="hljs-number">2</span>的连线之间形成的夹角小于<span class="hljs-number">180</span>度，则认为V<span class="hljs-number">1</span>是耳点。所以一个由<span class="hljs-number">4</span>个顶点组成的多边形中，至少有<span class="hljs-number">2</span>个耳点。<span class="hljs-attribute">3</span>.耳朵三角形，三角形顶点中有耳点的就叫耳朵三角形。</code></pre><p>如果出现了空洞的话:</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>，用外围的简单多边形上的点，连接‘洞’的简单多边形，因此为了保持所有点的一致性，‘洞’必须是与外围的多边形的点的顺序是相反的。即外围如果是逆时针的顺序，‘洞’则需要顺时针的顺序。<span class="hljs-number">2</span>，在连接处，产生两个一模一样的点，即连接点。</code></pre><p>下面以图片来做演示:</p><h4 id="不包含洞与岛"><a href="#不包含洞与岛" class="headerlink" title="不包含洞与岛"></a>不包含洞与岛</h4><p><img src="/images/20201102143845357_29727.png" alt="移除耳朵&lt;2,3,4&gt;"></p><p>首先初始的时候凸顶点集合C={0,1,3,4,6,9}，初始凹顶点集合R={2,5,7,8},初始的耳朵集合E={3,4,6,9}(三角形0,1,2中间有一个顶点7,所以1不是耳朵)。<br>然后将顶点3去除后,2还是凹顶点,4还是耳朵顶点,所以这两集合不变。</p><p><img src="/images/20201102145420628_8434.png" alt="移除耳朵&lt;2,4,5&gt;"></p><p>接着移除4,5从凹顶点变成了凸顶点,并且成为了耳朵,所以将5从凹顶点移除,加入耳朵顶点集合。<br>凹节点集合R={2,7,8},耳朵集合E={5,6,9}</p><p><img src="/images/20201102145515174_12136.png" alt="移除&lt;2,5,6&gt;"></p><p>移除5,此时2变成了凸顶点,但由于7在&lt;1,2,6&gt;中,所以不是耳朵,R={7,8}(移除了2)，耳朵集合E={6,9}(移除了5)。</p><p><img src="/images/20201102150507996_5553.png" alt="移除&lt;2,6,7&gt;"></p><p>此时2变成了耳朵,耳朵集合E={9,2}(添加2移除6)。</p><p><img src="/images/20201102150932259_10630.png" alt="移除&lt;8,9,0&gt;"></p><p>8变成了耳朵,0也从凸节点变成了耳朵,凹点集合R={7}，耳朵集合E={0,2,8}(添加8 ，添加0，移除9)。</p><p><img src="/images/20201102151517995_26348.png" alt="移除&lt;8,0,1&gt;"></p><p>耳朵列表变为E={2,8}(移除了0)。</p><p><img src="/images/20201102151650243_7485.png" alt="移除&lt;1,2,7&gt;"></p><p>只剩下了三个顶点,组成最后一个三角形。</p><p><img src="/images/20201102151802696_25394.png" alt="完成分割的多边形"></p><h4 id="含有洞与岛的情况"><a href="#含有洞与岛的情况" class="headerlink" title="含有洞与岛的情况"></a>含有洞与岛的情况</h4><p><img src="/images/20201102152814664_31049.png" alt="含有岛洞的多边形"></p><p>注意:<strong>外侧多边形的定点方形和内测岛洞的顶点方向必须是相反的。如果外侧的顶点是逆时针顺序，那么内测的顶点则必须是顺时针顺序。</strong></p><p>首先将其构造成简单多边形,连接&lt;11,16&gt;,同时复制这两点连接&lt;19,18&gt;,两条边重合,方向相反,以此将该多边形构造成简单多边形,去除了空洞。</p><p><img src="/images/20201102153101248_22291.png"></p><p>图中蓝色的顶点是互相可见的,<strong>在顶点数据结构不同的情况下,互相可见的顶点必须复制</strong>。每个数据结构存储当前点可能是凹点也可能是凸点。即使使用同一个坐标的两个点，也可能一个是凹点，一个是凸点，比如位于最下面的蓝色顶点11(18)。原始的顶点在最初的外多边形中是凹点，分割后在新的多边形中，V11与红色边相连，构成了一个凹点，与蓝色边相连构成另一个凸点。</p><pre><code class="hljs angelscript">原始的外多边形顶点数据：&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>&#125;原始的内多边形数据&#123;<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>&#125;分割后顶点V11被复制出V18，顶点V16复制出V19，这时候的简单多边形数据如下：&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">18</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>&#125;新的多边形即可以使用耳朵裁剪法切割。</code></pre><h5 id="寻找互相可见点"><a href="#寻找互相可见点" class="headerlink" title="寻找互相可见点"></a>寻找互相可见点</h5><p>上图中，11与16是一对相互可见点，但其实这样的点不止其一对，一个点来自外多边形，一个点来自内多边形，所以需要一个算法来寻找这样的多边形点。</p><p>以内多边形的最右点(X最大的点)为原点，向右作射线，如首先交于外多边形的顶点，则该顶点为相互可见点，而一般会相交于边上一点，设相交于I点，该边两端点离M(原点)最近的点就是相互可见点。</p><p><img src="/images/20201102160834441_5555.png" alt="相互可见点Ⅰ"></p><p>但有时候可能会出现被阻挡的情况。</p><p><img src="/images/20201102162211971_6308.png" alt="MP不可见"></p><p>此时有A、B、C三点在三角形MIP内部，获取这三点与M的连线与MI的夹角，取夹角最小的为互相可见点。</p><pre><code class="hljs angelscript">算法总结如下:<span class="hljs-number">1</span>、寻找内部多边形x周最大值的顶点M<span class="hljs-number">2</span>、沿X周正方向，寻找最近的相交边&lt;Vi,Vi+<span class="hljs-number">1</span>&gt;,让其焦点设置为I，构成X轴方向对M的最近可见点<span class="hljs-number">3</span>、如果I是一个外部顶点，则M和I相互可见，算法执行结束<span class="hljs-number">4</span>、如果I只是边上的一个点，寻找端点中x值片的一个，设置为P<span class="hljs-number">5</span>、寻找位于P内的其他外多边形的可连接顶点。如果所有的顶点都在&lt;M,I,P&gt;之外，则M与P相互可见，反正结果<span class="hljs-number">6</span>、如果有至少一个点位于三角形&lt;M,I,P&gt;内部，则寻找其中的一个顶点，计算其与x轴(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)的夹角，夹角最小的顶点R与M构成相互可见边，算法结束<span class="hljs-number">7</span>、在这个算法中，有可能有多个顶点同事具有最小的角度，这种情况下，寻找距离M最近的一个点即可</code></pre><h4 id="含有多个岛洞的多边形"><a href="#含有多个岛洞的多边形" class="headerlink" title="含有多个岛洞的多边形"></a>含有多个岛洞的多边形</h4><p>此处的岛洞都仅被外多边形包含，彼此不存在嵌套岛洞的情形</p><p><img src="/images/20201102162719643_22015.png" alt="含有多个岛洞"></p><p>内多边形I1没有任何一个顶点与外部多边形相互可见，多边形I0则拥有多个与外部多边形相互可见的点。因此，我们可以使用前面介绍的算法，首先把I0和外部多边形拆分，合并成为一个简单多边形，这样，新形成的外多边形则和I1构成了一件简单多边形，使用耳切法分割集合。</p><h4 id="嵌套多边形"><a href="#嵌套多边形" class="headerlink" title="嵌套多边形"></a>嵌套多边形</h4><p>内多边形也可能包含一些泪如岛洞的外多边形，类如嵌套。这样导致了嵌套多边形的树形结构。根节点是最外围的外多边形，子节点则是包含在当前最外多边形内部的内多边形。每一个孙子节点，则是构成直接被最外围多边形包含的内多边形的子树，每个多边形树可以按照宽度优先去遍历。</p><p><img src="/images/20201102163503259_27207.png" alt="嵌套多边形"></p><p><img src="/images/20201102164111846_32408.png" alt="树形结构Ⅰ"></p><p>使用上面的获取互相可见边的方法，可以生成新的简单多边形，对每个内多边形都做这样的操作，完成最终的三角划分，以便获取最终的索引顺序，来代替最初的多边形顶点定义顺序。相比原始的值，这里可能需要复制一些顶点，以便被多个三角形使用。</p>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NavMesh</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NavMesh</title>
    <link href="/2020/10/29/NavMesh/"/>
    <url>/2020/10/29/NavMesh/</url>
    
    <content type="html"><![CDATA[<h1 id="NavMesh"><a href="#NavMesh" class="headerlink" title="NavMesh"></a>NavMesh</h1><p><a href="https://wo1fsea.github.io/2016/08/21/A_Quick_Introduction_to_NavMesh/">NavMesh</a></p><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><ul><li>首先对地图进行栅格化（分成一个个小格），然后就可以根据栅格化的地图获取到内边缘<br><img src="/images/20201022141248234_23947.png"></li><li>接下来对边缘进行简化首先找到两个点连线得到简化的边缘<br><img src="/images/20201022142131618_27103.png"></li><li>然后找到距离该线最远的点，加入顶点集合中<br><img src="/images/20201022142424297_28453.png"><br>重复该过程，直到所有不在简化轮廓集合中的点距离简化的边缘距离都小于某阈值。</li><li>由于角色体型不同时，路径应该不同，在提取地图区域边缘时，向内多取一个角色体型半径生成特殊的寻路地图（即每种半径生成一个寻路网格）。<br><img src="/images/20201022144128943_29308.png"><br><img src="/images/20201022144114158_15868.png"></li><li>进行空间的划分<br><img src="/images/20201022162123919_2043.png"><br>首先设置一个阈值，当<strong>两点间直线距离/两点边界距离</strong>小于该值时，进行区域分割。<br><img src="/images/20201022162635191_27753.png"><br>该过程可使用递归进行。<br>完成分割后，每块区域作为图的一个节点，每两个点之间都可以通过简单的直线路径连通。<br>可以用最短路径算法（如 Dijkstra ）来解决图节点间的寻路问题，而图节点内的路径可以简单的通过两点间连线完成。<br><img src="/images/20201022163352484_11008.png"><br>对于有空洞的地图，在进行边缘简化后，对每个空洞区域，找到其和地图边界点距离最近的点，连接起来作为边界。<br><img src="/images/20201022164056252_26253.png"></li><li>动态障碍<br>可在运行时，修改地图与动态障碍物重叠的节点数据。<br><img src="/images/20201022164332728_4957.png"><h2 id="寻路"><a href="#寻路" class="headerlink" title="寻路"></a>寻路</h2>Unity中使用的基础算法是A*。<h3 id="漏斗算法"><a href="#漏斗算法" class="headerlink" title="漏斗算法"></a>漏斗算法</h3></li><li>使用A*之类的算法计算出从起点到终点所走过的多边形/三角形的集合。</li><li>使用漏斗算法，将多边形集合转换成最优路径。<br><img src="/images/20201022165003280_24116.png"></li><li>首先计算出三角形列表中的邻接边列表，所谓邻接边就是两个三角形公用的边<br><img src="/images/20201022170130106_31434.png"><br>图中橙色边即邻接边，绿色为<strong>漏斗边</strong>。</li><li>将<strong>漏斗边</strong>移至下一条邻接边的两端，如果漏斗边的夹角变小或不变就算此次移动有效。<br><img src="/images/20201022170742425_6891.png"></li><li>继续移动，如果出现了漏斗角的度数变成负数，例如右漏斗边移动到了左漏斗边的左侧，那么被盖过去的那条边的终点就成为了结果中的第一个点。同时将漏斗边的起点移到该点，构建出新漏斗。<br><img src="/images/20201022171050194_20813.png"></li><li>如果遇到度数变大的情况，不动（虽然发生了移动但终点和起点一致）的那条边移动成功，导致度数变大的边移动失败（即其不发生移动）。<br><img src="/images/20201022171614258_16517.png"></li><li>结束时，算法已经移动到了最后一条邻接边，但是从现在的漏斗底直接连一条线到终点肯定是不可行的。随后我们以终点一个点，当作一条两条端点相同的边。用它继续前进漏斗口。右边的漏斗边如果移动，会使漏斗口变大，因此不移动，左边的漏斗边移动，会盖过右边的漏斗边，因此右边的漏斗边终点成为了结果中的另一个点。<br><img src="/images/20201022171731929_30643.png"></li><li>同样，以该点所在三角形的出邻接边重新构造漏斗，继续算法，很快就会发现漏斗口到终点，收到了最小，算法结束。<br><img src="/images/20201022171754374_20441.png"></li></ul>]]></content>
    
    
    <categories>
      
      <category>Navigation</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NavMesh</tag>
      
      <tag>Navigation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿巴阿巴</title>
    <link href="/2020/10/28/%E9%98%BF%E5%B7%B4%E9%98%BF%E5%B7%B4/"/>
    <url>/2020/10/28/%E9%98%BF%E5%B7%B4%E9%98%BF%E5%B7%B4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
